! ecmwf netcdf filer...   ls /fou/nwparc2/ec/2013/.nc
SUBROUTINE MNCMASK(UNITI,IRC)
  ! 
  ! ***********************************************************************
  ! +                                                                     *
  ! +  UNITI = UNIT NUMBER FOR INPUT FILE                                 *
  ! +  IRC=ERROR RETURN CODE (0=OK)                                       *
  ! +                                                                     *
  ! +                                                                     *
  ! VERSION                      : 01/01/00                               *
  ! +                                                                     *
  ! WRITTEN/MODIFIED BY:                                                  *
  ! --------------------------------------------------------------------- *
  ! |    NAME      |   DATE   |                 REASON                  | *
  ! --------------------------------------------------------------------- *
  ! | F. TVETER    | 01/08/14 | NEW                                     | *
  ! |              |          |                                         | *
  ! --------------------------------------------------------------------- *
  ! ***********************************************************************
  !
  use xmlparse
  use ncf
  use sim
  IMPLICIT NONE
  SAVE
  ! INTERFACE VARIABLES
  ! 
  INTEGER  UNITI
  INTEGER IRC
  ! 
  CHARACTER*12 MYNAME
  DATA MYNAME /'MNCMASK'/
  ! 
  INTEGER  IKODE,OKODE
  LOGICAL  OK,LFLDAT(100),BDEB,ACTIVE,found
  DATA BDEB   /.false./
  DATA ACTIVE /.FALSE./
  ! 
  integer unitx,ftunit
  external ftunit
  integer lenx,leny,lenn,lenv,opos,cpos,lenp,len2
  INTEGER  KODE, lena, lend, lenb, lenh, lene, lenr
  integer, external:: length
  character*250 :: buff250
  ! 
  INTEGER  LINE
  INTEGER  NRHDR
  PARAMETER (NRHDR=100)
  !
  real :: tanfact = 1.0
  real :: timfact = 1.0
  !
  ! xml-macroes
  !
  integer, parameter :: xml_criterium   = 1 ! obsolete
  integer, parameter :: xml_type        = 2 ! obsolete
  integer, parameter :: xml_color       = 3 ! obsolete
  integer, parameter :: xml_level       = 4 ! obsolete
  integer, parameter :: xml_issued      = 5
  integer, parameter :: xml_issued_yy   = 6
  integer, parameter :: xml_issued_mm   = 7
  integer, parameter :: xml_issued_dd   = 8
  integer, parameter :: xml_issued_hh   = 9
  integer, parameter :: xml_issued_epoch= 11
  integer, parameter :: xml_start_epoch = 12
  integer, parameter :: xml_stop_epoch  = 13
  integer, parameter :: xml_start       = 14
  integer, parameter :: xml_stop        = 15
  integer, parameter :: xml_expires     = 16
  integer, parameter :: xml_minval      = 17
  integer, parameter :: xml_minval_lat  = 18
  integer, parameter :: xml_minval_lon  = 19
  integer, parameter :: xml_minval_time = 20
  integer, parameter :: xml_minval_dt   = 21
  integer, parameter :: xml_minval_dc   = 22
  integer, parameter :: xml_minval_yy   = 23
  integer, parameter :: xml_minval_mm   = 24
  integer, parameter :: xml_minval_dd   = 25
  integer, parameter :: xml_minval_hh   = 26
  integer, parameter :: xml_maxval      = 27
  integer, parameter :: xml_maxval_lat  = 28
  integer, parameter :: xml_maxval_lon  = 29
  integer, parameter :: xml_maxval_time = 20
  integer, parameter :: xml_maxval_dt   = 30
  integer, parameter :: xml_maxval_dc   = 31
  integer, parameter :: xml_maxval_yy   = 32
  integer, parameter :: xml_maxval_mm   = 33
  integer, parameter :: xml_maxval_dd   = 34
  integer, parameter :: xml_maxval_hh   = 35
  integer, parameter :: xml_minaux      = 36
  integer, parameter :: xml_maxaux      = 37
  integer, parameter :: xml_acc_hh      = 38
  integer, parameter :: xml_iter        = 39
  integer, parameter ::  mxmlvar =39
  integer, parameter :: key_issued      = 1
  integer, parameter :: key_issued_yy   = 2
  integer, parameter :: key_issued_mm   = 3
  integer, parameter :: key_issued_dd   = 4
  integer, parameter :: key_issued_hh   = 5
  integer, parameter :: key_issued_epoch= 6
  integer, parameter :: key_par_name    = 7
  integer, parameter ::  mkeyvar = 7
  !
  ! types of operations
  !
  integer, parameter :: opr_inter = 1
  integer, parameter :: opr_union = 2
  integer, parameter :: opr_filter = 3
  !
  ! types of filters
  !
  integer, parameter :: flt_slice = 1
  integer, parameter :: flt_cylinder = 2
  integer, parameter :: flt_polygon = 3
  integer, parameter :: flt_duct = 4
  integer, parameter :: flt_value = 5
  integer, parameter :: flt_string = 6
  integer, parameter :: flt_dimension = 7
  !
  ! types of targets...
  !
  integer, parameter :: trg_fraction=1  ! fraction
  integer, parameter :: trg_area=2      ! area
  integer, parameter :: trg_count=3     ! count
  integer, parameter :: trg_macro=4     ! macro
  integer, parameter :: trg_average=5   ! average
  !
  ! fail modes
  !
  integer, parameter :: fail_NoData=1
  integer, parameter :: fail_AnyData=2
  integer, parameter :: fail_None=3
  integer, parameter :: fail_Size=4
  !
  integer mxml,mkey,mtim,mtrg,mpst
  parameter(mxml=20,mkey=25,mtim=250,mtrg=100,mpst=1)
  !
  ! xml variables
  !
  type xmltype
     character*700 b700
     INTEGER  INTOUT
     LOGICAL  ENDOFF
     logical           :: mustread
     type(XML_PARSE)   :: info
     character(len=80)                      :: tag
     logical                                :: starttag
     logical                                :: endtag
     character(len=700), dimension(1:2,1:20) :: attribs
     integer                                :: no_attribs
     character(len=700), dimension(1:100)   :: data
     integer                                :: no_data
  end type xmltype
  !
  type filter ! filter definition
     integer               :: type = 0
     character*250         :: name250 = ""
     character*250         :: file250 = ""
     real                  :: eps=10.0D0
     real                  :: delta=0.0D0
     logical               :: inside = .true.
     logical               :: simplify = .true.
     logical               :: ledge = .false.
     integer               :: mpar=0
     logical, allocatable  :: lpar(:)
     integer, allocatable  :: npar(:)
     real, allocatable     :: rpar(:)
     character*250         :: spar250
     integer               :: lens
     character*80          :: sdim80 = ""
     logical               :: ipar = .false.
     logical               :: active = .false.
     character*250         :: var250 = ""! variable to be loaded
     type(DimensionOrder), pointer :: sdo => null()
     type(inventory), pointer :: i => null()
     type(variable), pointer :: v => null()
     real :: minval = 0.0D0
     real :: maxval = 0.0D0
     ! chain
     type(filter), pointer :: next=>null()
     type(filter), pointer :: prev=>null()
  end type filter
  !
  type operation ! an operation may consist of other operations
     integer                  :: type = 0 ! mask,intersection,union
     character*250            :: name250 = "undefined"
     type(filter), pointer    :: f
     logical                  :: ignore
     ! tree
     type(operation), pointer :: first=>null()
     type(operation), pointer :: last=>null()
     type(operation), pointer :: parent=>null()
     ! chain
     type(operation), pointer :: next=>null()
     type(operation), pointer :: prev=>null()
  end type operation
  !
  type report
     integer :: ntim,npst
     integer nxml,nkey
     logical :: laux
     type(variable), pointer :: vaux=>null()
     real :: auxmin(mtim,mpst),auxmax(mtim,mpst)
     !
     character*700 xml700(2,mxml),aux700(2),key700(2,mkey)
     character*350 xmlo350,poly350 ! var350,
     logical :: lpoly=.false.
     ! targets
     logical :: ltrg=.false.
     integer :: mrest=0
     integer :: nrest=0
     integer :: arest=0
     real, allocatable :: key1(:,:,:)
     integer, allocatable :: nkey1(:,:),nkey0(:,:),keyind(:,:,:)
     ! macros...
     character*350 xmlvar350(mxmlvar,mtim,mpst)
     character*350 keyvar350(mkeyvar)
     ! statistics
     real valmin(mtim,mpst),valmax(mtim,mpst),valavg(mtim,mpst),valcnt(mtim,mpst)
     real llmin(2,mtim,mpst),llmax(2,mtim,mpst)
     integer ttmin(mtim,mpst),ttmax(mtim,mpst)
     logical lfirst(mtim,mpst),lmin,lmax
     real tj2000(mtim)
     ! targets
     integer ntrg
     real trgval(mtrg)
     character*700 :: trgvar700(mtrg)
     integer trgtyp(mtrg)
     character*10 trg10(mtrg)
     logical trgreq(mtrg)
     ! average values
     logical :: lavg=.false.
     character*10 :: avg10
     ! filter
     type(operation),pointer :: roperation => null() ! root operation
     type(operation),pointer :: coperation => null() ! current operation
     type(filter), pointer :: firstfilter=> null()
     type(filter), pointer :: lastfilter => null()
     ! report chain
     type(report), pointer :: next=>null()
     type(report), pointer :: prev=>null()
  end type report
  !
  type parameter
     logical :: find=.false.
     logical :: fiad=.false.
     logical :: fino=.false.
     character*350 :: par350
     integer :: nrep=0
     ! variable
     real :: hrs=0.0D0            ! accumulation hours
     type(variable), pointer :: var=>null()
     ! targets
     ! report chain
     type(report), pointer :: firstreport=>null()
     type(report), pointer :: lastreport=>null() ! filter definition chain
     ! parameter chain
     type(parameter), pointer :: next=>null()
     type(parameter), pointer :: prev=>null()
  end type parameter
  !
  type filetype
     real i2000,a2000,tt2000
     real t2000, dt, mint2000,maxt2000
     character*24 i24,s24,e24,a24,t24
     integer :: tmin, tmax
     integer :: mtime,mrest=0,mpst=0
     real :: keep=0.0D0, cutoff=0.0D0, maxdays=1000.0D0
     character*350 :: inp350,ref350,nco350 ! file names
     character*80 :: iter80
     integer :: leni=0
     logical :: nodata = .true.
     integer rok(10), rrm(10)
     real pst(10)
     real :: darea = 1.0D0
     integer :: npar=0
     logical :: firsttrg=.true.,firstt=.true.
     type(inventory),pointer  :: ref => null()
     type(inventory),pointer  :: g => null()
     type(inventory) :: out
     type(variable), pointer  :: v,i=>null()
     type(Dimension), pointer :: ix => null(),iy=>null()
     type(dimensionOrder), pointer :: refParDO => null()
     type(dimensionOrder),pointer  :: refLatDO,refLonDO,refAltDO,refTimDO,refAllDO,refIterDO
     type(dimensionOrder),pointer  :: refLatLonAltDO,refOut,refInn,refStrDO,refDimDO
     type(dimensionOrder),pointer  :: refLatLonDO
     type(parameter), pointer :: firstparameter=> null()
     type(parameter), pointer :: lastparameter => null()
  end type filetype
  !
  ! global variables
  !
  type(xmltype) :: xml
  type(filetype) :: file
  !
  ! dynamic keys
  !
  type(filter), pointer :: nfilter => null()
  type(filter), pointer :: cfilter => null()
  type(operation),pointer :: noperation => null() ! new operation
  real :: hrs=0.0D0
  character*700 :: var700,b700
  !
  real :: maxval,minval
  integer cnt,cntud
  !
  integer ee, tt, ii,jj,kk,ll
  real lat,lon,alt
  !
  logical bok, bbok
  character*250 :: sval250
  integer :: lens
  integer fexp
  type(attribute), pointer :: a
  integer lenk
  !
  real re
  parameter (re = 6371.0D3)
  !parameter (eps = 10.0D0) ! allow 10 km error in polygon
  logical :: fail(4)
  logical :: exists

  IRC=0
  ! 
  ! DEBUG SYSTEM
  ! 
  ! IF (.NOT.ACTIVE) CALL DEBUG(MYNAME,BDEB,ACTIVE)
  ! bdeb=.true.
  ! bdeb=.FALSE.
  ! 
  BDEB = .false.
  IF (BDEB) WRITE(*,*) MYNAME,'Debug: Routine starts.',IRC
  open( 20, file = 'xml.debug' )
  !
  ! initialise
  !
  call initFile(file,irc)
  if (irc.ne.0) then
     write(*,*)myname,'Error return from initfile.',irc
     return
  end if
  !
  file%inp350=""
  call readXmlFile(file,irc)
  if (irc.ne.0) then
     write(*,*)myname,'Error return from readXmlfile.',irc
     return
  end if
  !
  ! read input file
  !
  file%rok(:)=0
  file%rrm(:)=0
  ! 
  WRITE(*,*) MYNAME,'----------------------------------------'
  !
  ! open file and read inventory
  !
  lenr=length(file%ref350,350,10)
  write(*,*)myname,'Opening: "'//file%ref350(1:lenr)//'"'
  allocate(file%ref,stat=irc)
  if (irc.ne.0) then
     write(*,*)myname,'Unable to allocate REF.',irc
     return
  end if
  call ncf_openFile(file%ref350,file%ref,bok,irc)
  if (irc.ne.0) then
     write(*,*)myname,'Error return from READINVENTORY.',irc
     return
  end if
  !
  call readDataFile(file,bok,irc)
  if (irc.ne.0) then
     write(*,*)myname,'Error return from readDatafile.',irc
     return
  end if
  if (.not.bok) then
     lenr=length(file%ref350,350,10)
     write(*,*)myname,'Corrupt file:',file%ref350(1:lenr)
     irc=347
     return
  end if
  !
  ! check exit conditions
  !
  call checkExitCondition(file,fail,irc)
  if (irc.ne.0) then
     write(*,*) myname,'Error return from checkExitCondition.',irc
     return
  end if
  !
  ! get time dimensions
  !
  call extractTimes(file,bok,irc)
  if (irc.ne.0) then
     write(*,*)myname,'Error return from getTimeInfo.',irc
     return
  end if
  !
  call matchAuxs(file,irc)
  if (irc.ne.0) then
     write(*,*)myname,'Error return from mathAuxs.',irc
     return
  end if
  !
  call processDataFile(file,fail,bok,irc)
  if (irc.ne.0) then
     write(*,*)myname,'Error return from processDataFile.',irc
     return
  end if
  !
  call ncf_closeFile(file%ref,irc) ! close file for reading
  if (irc.ne.0) then
     write(*,*)myname,'Error return from closeFile.',irc
     irc=0
     ! return
  end if
  !
  write(*,*)myname,'Sorting:   ',file%npar,file%mtime
  ! sort filtered values so that we can find dynamic targets (a100, a95...)
  call sortTargetData(file,irc)
  if (irc.ne.0) then
     write(*,*)myname,'Error return from sortTargetData.',irc
     return
  end if
  !
  ! recover data...
  !
  if (bok) then  
     ! print times...
     if (associated(file%ref%timid)) then
        call ncf_countField(file%ref%timid,cnt,cntud,minval,maxval,irc)
        if (irc.ne.0) then
           write(*,*)myname,'Error return from COUNTFIELD.',irc
           return
        end if
     end if
     !
     call ncf_unmakeAllRealData(file%ref,irc)
     if (irc.ne.0) then
        write(*,*) myname,'Error return from unmakeAllRealData.',irc
        return
     end if
     !
     ! write time information
     !
     call writeTimes(file,irc)
     if (irc.ne.0) then
        write(*,*) myname,'Error return from writeTimes.',irc
        return
     end if
     !
     ! make key information...
     !
     call processKeys(file,irc)
     if (irc.ne.0) then
        write(*,*) myname,'Error return from processKeys.',irc
        return
     end if
     !
     ! remove unused dimensions and write to file
     !
     call ncf_compressVariables(file%ref,irc) ! compress variables
     if (irc.ne.0) then
        write(*,*)myname,'Error return from compressVariables.',irc
        return
     end if
     call ncf_compressDimensions(file%ref)
     call ncf_writeNcOut(file%ref,file%nco350,irc)
     if (irc.ne.0) then
        write(*,*) myname,'Error return from writeNcOut.',irc
        return
     end if
     !
     call writeReports(file,irc)
     if (irc.ne.0) then
        write(*,*)myname,'Error return from writeReports.',irc
        return
     end if
     !
  else
     call hintReports(file,irc)
     if (irc.ne.0) then
        write(*,*)myname,'Error return from hintReports.',irc
        return
     end if
     !
     ! clean up
     call ncf_clearData(file%ref,irc)
     if (irc.ne.0) then
        write(*,*)myname,'Error return from cleanMemory.',irc
        return
     end if
  end if ! bok
  !
  call clearFile(file,irc)
  if (irc.ne.0) then
     write(*,*)myname,'Error return from clearFile.',irc
     return
  end if
  !
  ! handle fail conditions
  !
  if (fail(fail_NoData).or.fail(fail_AnyData).or.fail(fail_size)) then
     write(*,*)myname,'FAIL condition encountered.'
     irc=100
  end if
  return
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
contains
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine initFile(file,irc)
    implicit none
    type(filetype) :: file
    integer :: irc
    CHARACTER*12 MYNAME
    DATA MYNAME /'initfile'/
    allocate(file%firstparameter,file%lastparameter,stat=irc)
    if (irc.ne.0) then
       write(*,*)myname,'Unable to allocate Parameter-chain.',irc
       return
    end if
    file%firstparameter%next => file%lastparameter
    file%lastparameter%prev => file%firstparameter
    !
    file%nco350="output.nc"
    file%iter80=""
    file%leni=0
    return
  end subroutine initFile
  !
  subroutine initParameter(cpar,irc)
    implicit none
    type(parameter), pointer :: cpar
    integer :: irc
    type(report), pointer :: crep
    CHARACTER*12 MYNAME
    DATA MYNAME /'iniparameter'/
    cpar%par350="UNDEFINED"
    if (associated(cpar%lastreport).and.associated(cpar%firstreport)) then
       crep=>cpar%firstreport%next
       do while (.not.associated(crep,target=cpar%lastreport))
          call clearReport(crep,irc)
          crep=>crep%next
       end do
       deallocate(cpar%firstreport,cpar%lastreport,stat=irc)
    end if
    allocate(cpar%firstreport,cpar%lastreport,stat=irc)
    if (irc.ne.0) then
       write(*,*)myname,'Unable to allocate first/last-report.',irc
       return
    end if
    cpar%firstreport%next => cpar%lastreport
    cpar%lastreport%prev => cpar%firstreport
    cpar%nrep=0
    return
  end subroutine initParameter
  !
  subroutine initReport(rep,irc)
    implicit none
    type(report), pointer :: rep
    integer :: irc
    CHARACTER*12 MYNAME
    DATA MYNAME /'initreport'/
    !
    rep%nxml=0
    rep%laux=.false.
    rep%nkey=0
    rep%ntrg=0
    rep%valcnt(:,:)=0.0D0
    rep%lfirst(:,:)=.true.
    rep%xmlo350="output.xml" ! report
    rep%lpoly=.false.
    rep%poly350="polygon.json" ! report
    rep%ntim=0
    rep%mrest=0
    rep%nrest=0
    rep%arest=0
    allocate(rep%firstfilter, rep%lastfilter,stat = irc)
    if (irc.ne.0) then
       write(*,*)myname,'Unable to allocate first/last-filter.',irc
       return
    end if
    rep%firstfilter%next => rep%lastfilter
    rep%lastfilter%prev => rep%firstfilter
    return
  end subroutine initReport
  !
  subroutine initFileKeys(file,irc)
    implicit none
    type(filetype) :: file
    integer :: irc
    type(parameter), pointer :: cpar
    type(report), pointer :: crep
    CHARACTER*12 MYNAME
    DATA MYNAME /'initkeys'/
    cpar=>file%firstparameter%next
    do while (.not.associated(cpar,target=file%lastparameter))
       ! loop over reports
       crep=>cpar%firstreport%next
       do while (.not.associated(crep,target=cpar%lastreport))
          call initKeys(file,crep,irc)
          crep=>crep%next
       end do
       cpar=>cpar%next
    end do
    return
  end subroutine initFileKeys
  !
  subroutine initKeys(file,rep,irc)
    implicit none
    type(filetype) :: file
    type(report), pointer :: rep
    integer :: irc
    integer :: ii
    CHARACTER*12 MYNAME
    DATA MYNAME /'initkeys'/
    if (rep%ltrg) then
       if (rep%mrest.eq.0) rep%mrest=file%mrest
       if (allocated(rep%nkey1)) deallocate(rep%nkey1)
       if (allocated(rep%nkey0)) deallocate(rep%nkey0)
       if (allocated(rep%key1)) deallocate(rep%key1)
       if (allocated(rep%keyind)) deallocate(rep%keyind)
       allocate(rep%nkey1(file%mtime,file%mpst),&
            & rep%nkey0(file%mtime,file%mpst),&
            & rep%key1(rep%mrest,file%mtime,file%mpst),&
            & rep%keyind(rep%mrest,file%mtime,file%mpst),&
            & stat=irc)
       if (irc.ne.0) then
          write(*,'(X,A,3(A,I0))') myname,&
               & 'Unable to allocate dynamic key variables. N=', &
               & rep%mrest," T=",file%mtime," irc=",irc
          return
       end if
       do tt=1,file%mtime
          do  ii=1,file%mpst
             rep%nkey1(tt,ii)=0
             rep%nkey0(tt,ii)=0
          end do
       end do
    else
       if (allocated(rep%nkey0)) deallocate(rep%nkey0)
       allocate(rep%nkey0(file%mtime,file%mpst),&
            & stat=irc)
       if (irc.ne.0) then
          write(*,'(X,A,3(A,I0))') myname,&
               & 'Unable to allocate some dynamic key variables. N=', &
               & rep%mrest," T=",file%mtime," irc=",irc
          return
       end if
    end if
    !
    return
  end subroutine initKeys
  !
  subroutine printReport(crep)
    implicit none
    type(report),pointer :: crep
    integer :: ii, lenk
    character*12 :: myname
    data myname /'printReport'/
    if (associated(crep)) then
       write(*,'(X,A,I0,A,I0)')"   Report  nkey=",crep%nkey," ntrg=",crep%ntrg
       do ii=1,crep%nkey
          write(*,'(X,A,I0,A)') "      key:",ii,&
               & ' "'//trim(crep%key700(1,ii))//'" -> "'//&
               & trim(crep%key700(2,ii))//'"'
       end do
       do ii=1,crep%ntrg
          write(*,'(X,A,I0,A,I0)') "      trg:",ii,&
               & ' "'//trim(crep%trg10(ii))//'" -> ',&
               & crep%trgtyp(ii)
       end do
    else
       write(*,*)myname,'Missing report...'
    end if
    return
  end subroutine printReport
  !
  subroutine printParameter(cpar)
    implicit none
    type(parameter), pointer :: cpar
    type(report), pointer    :: crep
    integer :: lenp
    character*16 :: myname
    data myname /'printParameter'/
    lenp=length(cpar%par350,350,10)
    write(*,'(X,A,A)')myname,'Parameter "'//cpar%par350(1:lenp)//'"'
    crep=>cpar%firstreport%next
    do while (.not.associated(crep,target=cpar%lastreport))
       call printReport(crep)
       crep => crep%next
    end do
    return
  end subroutine printParameter
  !
  subroutine printFile(file)
    implicit none
    type(filetype) :: file
    type(parameter), pointer :: cpar
    character*12 myname
    data myname /'printFile'/
    cpar => file%firstparameter%next
    do while (.not.associated(cpar,target=file%lastparameter))
       call printParameter(cpar)
       cpar => cpar%next
    end do
    return
  end subroutine printFile
  !
  character*100 function strFilter(f)
    implicit none
    type(filter), pointer :: f
    character*100 :: buff100
    integer :: lenb,lenn
    if (associated(f)) then
       write(strFilter,'(A,I0,A)') "("//&
            & trim(f%name250)//"|"//&
            & trim(f%file250)//"|",&
            & f%mpar,")"       
    else
       strFilter="(NA)"
    end if
    return
  end function strFilter
  !
  recursive subroutine printMask(cop,lev)
    implicit none
    type(operation), pointer :: cop
    integer :: lev
    type(operation), pointer :: pop
    character*20 :: blank20="                    "
    integer :: ilev
    character*12 myname
    data myname /'printMask'/
    ilev=lev+1
    write(*,'(A,I0,A)') blank20(1:min(lev,20))//">"//trim(cop%name250)//" :",&
         & cop%type,":"//trim(strFilter(cop%f))
    pop => cop%first%next
    do while (.not.associated(pop,target=cop%last))
       call printMask(pop,ilev)
       pop => pop%next
    end do
    return
  end subroutine printMask
  !
  subroutine addParameter(file,par,irc)
    implicit none
    type(filetype) :: file
    type(parameter), pointer :: par
    integer :: irc
    par%prev => file%lastparameter%prev
    par%next => file%lastparameter
    file%lastparameter%prev%next => par
    file%lastparameter%prev => par
    file%npar=file%npar+1
    return
  end subroutine addParameter
  !
  subroutine addReport(par,rep,irc)
    implicit none
    type(parameter), pointer :: par
    type(report), pointer :: rep
    integer :: irc
    if (rep%ntim.ne.0.or.rep%nxml.ne.0.or. rep%laux .or.rep%nkey.ne.0) then
       rep%prev => par%lastreport%prev
       rep%next => par%lastreport
       par%lastreport%prev%next => rep
       par%lastreport%prev => rep
       par%nrep=par%nrep+1
    else
       write(*,*)myname,'Ignoring empty report...'
       call clearReport(rep,irc)
       if (irc.ne.0) then
          write(*,*) myname,'Error return from clearReport.',irc
          return
       end if
    end if
    return
  end subroutine addReport
  !
  subroutine clearFile(file,irc)
    implicit none
    type(filetype) :: file
    integer :: irc
    type(parameter), pointer :: cpar,npar
    CHARACTER*14 MYNAME
    DATA MYNAME /'clearFile'/
    cpar=>file%firstparameter%next
    do while (.not.associated(cpar,target=file%lastparameter))
       npar=>cpar%next
       call clearParameter(cpar,irc)
       cpar=>npar
    end do
    call clearParameter(file%firstparameter,irc)
    call clearParameter(file%lastparameter,irc)
    file%npar=0
    return
  end subroutine clearFile
  !
  subroutine clearParameter(cpar,irc)
    implicit none
    type(parameter), pointer :: cpar
    integer :: irc
    type(report), pointer :: crep
    CHARACTER*14 MYNAME
    DATA MYNAME /'clearParameter'/
    if (associated(cpar%firstreport).and.associated(cpar%lastreport)) then
       crep=>cpar%firstreport%next
       do while (.not.associated(crep,target=cpar%lastreport))
          call clearReport(crep,irc)
          crep=>crep%next
       end do
       call clearReport(cpar%firstreport,irc)
       call clearReport(cpar%lastreport,irc)
    end if
    cpar%nrep=0
    deallocate(cpar)
    nullify(cpar)
    return
  end subroutine clearParameter
  !
  subroutine clearReport(crep,irc)
    implicit none
    type(report), pointer :: crep
    integer :: irc
    type(filter), pointer :: cflt,nflt
    CHARACTER*14 MYNAME
    DATA MYNAME /'clearReport'/
    if (allocated(crep%nkey1))  deallocate(crep%nkey1)
    if (allocated(crep%nkey0))  deallocate(crep%nkey0)
    if (allocated(crep%key1))   deallocate(crep%key1)
    if (allocated(crep%keyind)) deallocate(crep%keyind)
    nullify(crep%vaux)
    call clearOperation(crep%roperation,irc)
    if (associated(crep%firstfilter).and.associated(crep%lastfilter)) then
       cflt=>crep%firstfilter%next
       do while (.not.associated(cflt,target=crep%lastfilter))
          nflt=>cflt%next
          call clearFilter(cflt,irc)
          cflt=>nflt
       end do
       deallocate(crep%firstfilter,crep%lastfilter,stat=irc)
    end if
    return
  end subroutine clearReport
  !
  subroutine clearOperation(copr,irc)
    implicit none
    type(operation), pointer :: copr
    integer :: irc
    CHARACTER*14 MYNAME
    DATA MYNAME /'clearOperation'/
    ! 
    return
  end subroutine clearOperation
  !
  subroutine clearFilter(cflt,irc)
    implicit none
    type(filter), pointer :: cflt
    integer :: irc
    CHARACTER*14 MYNAME
    DATA MYNAME /'clearFilter'/
    if (allocated(cflt%lpar)) deallocate(cflt%lpar)
    if (allocated(cflt%npar)) deallocate(cflt%npar)
    if (allocated(cflt%rpar)) deallocate(cflt%rpar)
    if (associated(cflt)) deallocate(cflt)
    nullify(cflt)
    return
  end subroutine clearFilter
  !
  subroutine readXmlFile(file,irc)
    implicit none
    type(filetype) :: file
    integer :: irc
    type(xmltype)  :: xml
    type(XML_PARSE) :: inc
    type(parameter), pointer :: cpar=>null()
    type(parameter), pointer :: bpar=>null()
    type(report), pointer :: crep
    integer leni,lenf
    CHARACTER*12 MYNAME
    DATA MYNAME /'readXmlFile'/
    !
    call replaceENV(file%inp350,irc)
    if (irc.ne.0) then
       write(*,*)myname,'Error return from replaceEnv.',irc
       return
    end if
    leni=length(file%inp350,350,20)
    call xml_open( xml%info, file%inp350(1:leni), .true. ) ! "" == stdin
    call xml_options( xml%info, report_lun = 20, report_details = .true. )
    XMLL: do
       call xml_get( xml%info, xml%tag, xml%starttag, xml%endtag, &
            & xml%attribs, xml%no_attribs, xml%data, xml%no_data )
       if ( .not. xml_ok(xml%info) ) exit
       if ( xml_error(xml%info) ) then
          write(*,*)  'Error input file.'
          write(20,*) 'Error input file.'
       endif
       write(20,* ) xml%tag, xml%endtag
       do ii = 1,xml%no_attribs
          write(20,'(i3,1x,3a)') ii, trim(xml%attribs(1,ii)), '=', trim(xml%attribs(2,ii))
       end do
       write(20,'(i3,1x,3a)') (ii, '>',trim(xml%data(ii)), '<', ii=1,xml%no_data)
       ! process XMLL
       if (bdeb) write(*,*)myname,'Found TOP tag:',trim(xml%tag),xml%starttag,xml%endtag
       if (trim(xml%tag).eq."program") then
       else if (trim(xml%tag).eq."file") then
          do ii=1,xml%no_attribs
             call replaceENV(xml%attribs(2,ii),irc)
             if (irc.ne.0) then
                write(*,*)myname,'Error return from replaceEnv.',irc
                return
             end if
             len2=length(xml%attribs(2,ii),700,10)    
             if (trim(xml%attribs(1,ii)).eq."input") then
                if (bdeb) write(*,*)myname,'Input file:',xml%attribs(2,ii)(1:len2)
                file%ref350=xml%attribs(2,ii)
                call chop0(file%ref350,350)
             elseif (trim(xml%attribs(1,ii)).eq."mask") then
                if (bdeb) write(*,*)myname,'Output netcdf file:',xml%attribs(2,ii)(1:len2)
                file%nco350=xml%attribs(2,ii)
                !lenn=len_trim(file%nco350)
                ! if (.not.crep%lpoly .and. file%nco350(lenn-2:lenn).eq.".nc") then
                !    crep%lpoly=.true.
                !    crep%poly350=trim(file%nco350(1:lenn-3)//".json")
                !    write(*,*)myname,"Polygon from netcdf:",trim(crep%poly350)
                ! end if
             elseif (trim(xml%attribs(1,ii)).eq."iter") then
                file%iter80=xml%attribs(2,ii)
             elseif (trim(xml%attribs(1,ii)).eq."keep") then
                if (bdeb) write(*,*)myname,'Input file:',xml%attribs(2,ii)(1:len2)
                read(xml%attribs(2,ii)(1:len2),*,iostat=irc) file%keep
                if (irc.ne.0) then
                   write(*,*)myname,'Unable to read keep "'//&
                        &xml%attribs(2,ii)(1:len2)//'"'
                   return
                end if
             elseif (trim(xml%attribs(1,ii)).eq."cutoff") then
                if (bdeb) write(*,*)myname,'Input file:',xml%attribs(2,ii)(1:len2)
                read(xml%attribs(2,ii)(1:len2),*,iostat=irc) file%cutoff
                if (irc.ne.0) then
                   write(*,*)myname,'Unable to read cutoff "'//&
                        &xml%attribs(2,ii)(1:len2)//'"'
                   return
                end if
             elseif (trim(xml%attribs(1,ii)).eq."maxdays") then
                if (bdeb) write(*,*)myname,'Input file:',xml%attribs(2,ii)(1:len2)
                read(xml%attribs(2,ii)(1:len2),*,iostat=irc) file%maxdays
                if (irc.ne.0) then
                   write(*,*)myname,'Unable to read keep "'//&
                        &xml%attribs(2,ii)(1:len2)//'"'
                   return
                end if
             else 
                write(*,*)myname,'Unknown attribute:',trim(xml%tag)//':'//&
                     & trim(xml%attribs(1,ii))
                irc=798
                return
             end if
          end do
          ! read until xml%endtag is reached
          INPUT: do while(.not. (trim(xml%tag).eq."input".and.xml%endtag))
             call xml_get( xml%info, xml%tag, xml%starttag, xml%endtag, &
                  & xml%attribs, xml%no_attribs, xml%data, xml%no_data )
             if ( .not. xml_ok(xml%info) ) exit INPUT
             if (bdeb) write(*,*)myname,'Found INPUT tag:',trim(xml%tag),&
                  & xml%starttag,xml%endtag
             if (trim(xml%tag).eq."parameter") then
                fail(fail_nodata)=.false.
                fail(fail_anydata)=.false.
                fail(fail_None)=.false.
                fail(fail_Size)=.false.
                if (xml%starttag) then
                   if (associated(cpar)) then
                      call clearParameter(cpar,irc)
                      irc=0
                      if (associated(cpar)) deallocate(cpar)
                   end if
                   allocate(cpar,stat=irc)
                   if (irc.ne.0) then
                      write(*,*)myname,'Unable to allocate PARAMETER.',irc
                      return
                   end if
                   call initParameter(cpar,irc)
                   do ii=1,xml%no_attribs
                      call replaceENV(xml%attribs(2,ii),irc)
                      if (irc.ne.0) then
                         write(*,*)myname,'Error return from replaceEnv.',irc
                         return
                      end if
                      len2=length(xml%attribs(2,ii),700,10)    
                      if (trim(xml%attribs(1,ii)).eq."name") then
                         cpar%par350=xml%attribs(2,ii)
                      elseif (trim(xml%attribs(1,ii)).eq."fail") then
                         if (xml%attribs(2,ii)(1:len2).eq."nodata") then
                            cpar%find= .true.
                         else if (xml%attribs(2,ii)(1:len2).eq."anydata") then
                            cpar%fiad= .true.
                         else if (xml%attribs(2,ii)(1:len2).eq."none") then
                            cpar%fino= .true.
                         else
                            write(*,*)myname,'Unknown setting:',trim(xml%tag)//':'//&
                                 & trim(xml%attribs(1,ii))
                         end if
                      else 
                         write(*,*)myname,'Unknown attribute:',trim(xml%tag)//':'//&
                              & trim(xml%attribs(1,ii))
                         irc=799
                         return
                      end if
                   end do
                   call chop0(cpar%par350,350)
                end if
                cnt=0
                PARR: do while(.not. (trim(xml%tag).eq."parameter".and.xml%endtag))
                   call xml_get( xml%info, xml%tag, xml%starttag, xml%endtag, &
                        & xml%attribs, xml%no_attribs, xml%data, xml%no_data )
                   if ( .not. xml_ok(xml%info) ) exit PARR
                   cnt=cnt+1
                   if (bdeb.and.cnt.lt.3) write(*,*)myname,'Found PAR tag:',&
                        & trim(xml%tag),xml%starttag,xml%endtag
                   if (bdeb.and.cnt.eq.3) write(*,*)myname,'Found PAR tag...'
                   if (trim(xml%tag).eq."report") then
                      ! prepare a new report...
                      allocate(crep,stat=irc)
                      if (irc.ne.0) then
                         write(*,*)myname,'Error allocating report.',irc
                         return
                      end if
                      call initReport(crep,irc)
                      if (irc.ne.0) then
                         write(*,*)myname,'Error return from initReport.',irc
                         return
                      end if
                      do ii=1,xml%no_attribs
                         call replaceENV(xml%attribs(2,ii),irc)
                         if (irc.ne.0) then
                            write(*,*)myname,'Error return from replaceEnv.',irc
                            return
                         end if
                         len2=length(xml%attribs(2,ii),700,10)    
                         if (trim(xml%attribs(1,ii)).eq."size") then
                            read(xml%attribs(2,ii)(1:len2),*,iostat=irc) crep%mrest
                            if (irc.ne.0) then
                               write(*,*)myname,'Unable to read size "'//&
                                    &xml%attribs(2,ii)(1:len2)//'"'
                               return
                            end if
                         end if
                      end do
                      REP: do while(.not. (trim(xml%tag).eq."report".and.xml%endtag))
                         call xml_get( xml%info, xml%tag, xml%starttag, xml%endtag, &
                              & xml%attribs, xml%no_attribs, xml%data, xml%no_data )
                         if ( .not. xml_ok(xml%info) ) exit REP

                         if (trim(xml%tag).eq."xml") then
                            do ii=1,xml%no_attribs
                               call replaceENV(xml%attribs(2,ii),irc)
                               if (irc.ne.0) then
                                  write(*,*)myname,'Error return from replaceEnv.',irc
                                  return
                               end if
                               len2=length(xml%attribs(2,ii),700,10)    
                               call addXML(crep,trim(xml%attribs(1,ii)),&
                                    & xml%attribs(2,ii)(1:len2));
                            end do
                         else if (trim(xml%tag).eq."aux") then
                            do ii=1,xml%no_attribs
                               call replaceENV(xml%attribs(2,ii),irc)
                               if (irc.ne.0) then
                                  write(*,*)myname,'Error return from replaceEnv.',irc
                                  return
                               end if
                               len2=length(xml%attribs(2,ii),700,10)    
                               call addAux(crep,trim(xml%attribs(1,ii)),&
                                    & xml%attribs(2,ii)(1:len2));
                            end do
                         else if (trim(xml%tag).eq."key") then
                            do ii=1,xml%no_attribs
                               call replaceENV(xml%attribs(2,ii),irc)
                               if (irc.ne.0) then
                                  write(*,*)myname,'Error return from replaceEnv.',irc
                                  return
                               end if
                               len2=length(xml%attribs(2,ii),700,10)    
                               call addKey(crep,trim(xml%attribs(1,ii)),&
                                    & xml%attribs(2,ii)(1:len2));
                            end do
                         else if (trim(xml%tag).eq."target".or.trim(xml%tag).eq."required") then
                            crep%ltrg=.true.
                            crep%ntrg=min(mtrg,crep%ntrg+1)
                            crep%trgreq(crep%ntrg)=(trim(xml%tag).eq."required")
                            do ii=1,xml%no_attribs
                               call replaceENV(xml%attribs(2,ii),irc)
                               if (irc.ne.0) then
                                  write(*,*)myname,'Error return from replaceEnv.',irc
                                  return
                               end if
                               len2=length(xml%attribs(2,ii),700,10)    
                               if (trim(xml%attribs(1,ii)).eq."name") then
                                  crep%trg10(crep%ntrg)=xml%attribs(2,ii)(1:len2)
                               else if (trim(xml%attribs(1,ii)).eq."fraction") then
                                  crep%trgtyp(crep%ntrg)=trg_fraction
                                  read(xml%attribs(2,ii)(1:len2),*,iostat=irc) &
                                       & crep%trgval(crep%ntrg)
                                  if (irc.ne.0) then
                                     write(*,*)myname,'Error reading attribute:',&
                                          & xml%attribs(2,ii)
                                     return
                                  end if
                               else if (trim(xml%attribs(1,ii)).eq."area") then
                                  crep%trgtyp(crep%ntrg)=trg_area
                                  read(xml%attribs(2,ii)(1:len2),*,iostat=irc) &
                                       & crep%trgval(crep%ntrg)
                                  if (irc.ne.0) then
                                     write(*,*)myname,'Error reading attribute:',&
                                          & xml%attribs(2,ii)
                                     return
                                  end if
                               else if (trim(xml%attribs(1,ii)).eq."count") then
                                  crep%trgtyp(crep%ntrg)=trg_count
                                  read(xml%attribs(2,ii)(1:len2),*,iostat=irc) &
                                       & crep%trgval(crep%ntrg)
                                  if (irc.ne.0) then
                                     write(*,*)myname,'Error reading attribute:',&
                                          & xml%attribs(2,ii)
                                     return
                                  end if
                               else if (trim(xml%attribs(1,ii)).eq."macro") then
                                  crep%trgtyp(crep%ntrg)=trg_macro
                                  crep%trgvar700(crep%ntrg)=xml%attribs(2,ii)
                               else if (trim(xml%attribs(1,ii)).eq."average") then
                                  crep%trgtyp(crep%ntrg)=trg_average
                                  read(xml%attribs(2,ii)(1:len2),*,iostat=irc) &
                                       & crep%trgval(crep%ntrg)
                                  if (irc.ne.0) then
                                     write(*,*)myname,'Error reading attribute:',&
                                          & xml%attribs(2,ii)
                                     return
                                  end if
                               end if
                            end do
                         else if (trim(xml%tag).eq."average") then
                            crep%lavg=.true.
                            do ii=1,xml%no_attribs
                               if (trim(xml%attribs(1,ii)).eq."name") then
                                  crep%avg10=xml%attribs(2,ii)(1:len2)
                               end if
                            end do
                         else if (trim(xml%tag).eq."output") then
                            do ii=1,xml%no_attribs
                               call replaceENV(xml%attribs(2,ii),irc)
                               if (irc.ne.0) then
                                  write(*,*)myname,'Error return from replaceEnv.',irc
                                  return
                               end if
                               len2=length(xml%attribs(2,ii),700,10)    
                               if (trim(xml%attribs(1,ii)).eq."xml") then
                                  if (bdeb) write(*,*)myname,'Output xml file:',&
                                       & xml%attribs(2,ii)(1:len2)
                                  crep%xmlo350=xml%attribs(2,ii)
                               else if (trim(xml%attribs(1,ii)).eq."polygon") then
                                  if (bdeb) write(*,*)myname,'Output polygon file:',&
                                       & xml%attribs(2,ii)(1:len2)
                                  crep%poly350=xml%attribs(2,ii)
                                  crep%lpoly=.true.
                               else 
                                  write(*,*)myname,'Unknown attribute:',&
                                       & trim(xml%tag)//':'//trim(xml%attribs(1,ii))
                                  irc=801
                                  return
                               end if
                            end do
                         else if (trim(xml%tag).eq."define") then
                            if (xml%starttag.and.xml%endtag) then
                               ! define new filter
                               allocate(nfilter,stat=irc)
                               if (irc.ne.0) then
                                  write(*,*)myname,'Unable to allocate filter.',irc
                                  return
                               end if
                               do ii=1,xml%no_attribs
                                  call replaceENV(xml%attribs(2,ii),irc)
                                  if (irc.ne.0) then
                                     write(*,*)myname,'Error return from replaceEnv.',irc
                                     return
                                  end if
                                  len2=length(xml%attribs(2,ii),700,10)    
                                  if (trim(xml%attribs(1,ii)).eq."filter") then
                                     if (bdeb) write(*,*)myname,'Filter name:',&
                                          & xml%attribs(2,ii)(1:len2)
                                     nfilter%name250=xml%attribs(2,ii)(1:len2)
                                  else if (trim(xml%attribs(1,ii)).eq."file") then
                                     inquire( file = xml%attribs(2,ii)(1:len2), exist = exists )
                                     if (.not.exists) then
                                        write(*,*)myname,"Invalid filter file:",&
                                             & xml%attribs(2,ii)(1:len2)
                                        irc=346
                                        return
                                     else
                                        write(*,*)myname,'Filter file:',xml%attribs(2,ii)(1:len2)
                                     end if
                                     nfilter%file250=xml%attribs(2,ii)(1:len2)
                                  else if (trim(xml%attribs(1,ii)).eq."tolerance") then
                                     read(xml%attribs(2,ii)(1:len2),*,iostat=irc) nfilter%eps
                                     if (irc.ne.0) then
                                        write(*,*)myname,'Error reading attribute:',xml%attribs(2,ii)
                                        return
                                     end if
                                     if (nfilter%eps <=0.0D0) then
                                        nfilter%simplify=.false.
                                     end if
                                  else if (trim(xml%attribs(1,ii)).eq."delta") then
                                     read(xml%attribs(2,ii)(1:len2),*,iostat=irc) nfilter%delta
                                     if (irc.ne.0) then
                                        write(*,*)myname,'Error reading attribute:',xml%attribs(2,ii)
                                        return
                                     end if
                                     nfilter%ledge=(nfilter%delta>0.0D0)
                                  else
                                     write(*,*)myname,'Unknown attribute:',&
                                          & trim(xml%tag)//':'//trim(xml%attribs(1,ii))
                                     irc=802
                                     return
                                  end if
                               end do
                               if (len_trim(nfilter%file250)>0) then
                                  call xml_open( inc, trim(nfilter%file250), .true. ) ! read file name
                                  call xml_options(inc, report_lun = 21, report_details = .false. )
                                  xml%endtag=.false. ! "open" the xml%tag and read the include-file
                                  call readFilter(crep,inc,xml,nfilter,irc)
                                  if (irc.ne.0) then
                                     write(*,*) myname,'Error return from readFilter.',irc
                                     return
                                  end if
                                  call xml_close( inc )
                               end if
                               nfilter%prev => crep%lastfilter%prev
                               nfilter%next => crep%lastfilter
                               crep%lastfilter%prev%next => nfilter
                               crep%lastfilter%prev => nfilter
                               nullify(nfilter)
                            end if
                            if (xml%starttag.and..not.xml%endtag) then
                               ! define new filter
                               allocate(nfilter,stat=irc)
                               if (irc.ne.0) then
                                  write(*,*)myname,'Unable to allocate filter.',irc
                                  return
                               end if
                               do ii=1,xml%no_attribs
                                  call replaceENV(xml%attribs(2,ii),irc)
                                  if (irc.ne.0) then
                                     write(*,*)myname,'Error return from replaceEnv.',irc
                                     return
                                  end if
                                  len2=length(xml%attribs(2,ii),700,10)    
                                  if (trim(xml%attribs(1,ii)).eq."filter") then
                                     if (bdeb) write(*,*)myname,'Filter name:',&
                                          & xml%attribs(2,ii)(1:len2)
                                     nfilter%name250=xml%attribs(2,ii)(1:len2)
                                  else
                                     write(*,*)myname,'Unknown attribute:',&
                                          & trim(xml%tag)//':'//trim(xml%attribs(1,ii))
                                     irc=802
                                     return
                                  end if
                               end do
                               call readFilter(crep,xml%info,xml,nfilter,irc)
                               if (irc.ne.0) then
                                  write(*,*) myname,'Error return from readFilter.',irc
                                  return
                               end if
                               ! insert into chain
                               nfilter%prev => crep%lastfilter%prev
                               nfilter%next => crep%lastfilter
                               crep%lastfilter%prev%next => nfilter
                               crep%lastfilter%prev => nfilter
                               nullify(nfilter)
                            else if (xml%endtag) then
                               call xml_get( xml%info, xml%tag, xml%starttag, &
                                    & xml%endtag, xml%attribs, xml%no_attribs, &
                                    & xml%data, xml%no_data )
                            end if
                         else if (trim(xml%tag).eq."mask") then
                            if (xml%starttag) then
                               if (associated(crep%roperation)) then
                                  write(*,*) myname,'Can only have one operation.'
                                  irc=348
                                  return
                               end if
                               allocate(crep%roperation,stat=irc) ! allocate root
                               if (irc.ne.0) then
                                  write(*,*)myname,'Unable to allocate mask.',irc
                                  return
                               end if
                               allocate(crep%roperation%first, &
                                    & crep%roperation%last,stat=irc)
                               if (irc.ne.0) then
                                  write(*,*)myname,'Unable to allocate mask-chain.',irc
                                  return
                               end if
                               crep%roperation%first%next => crep%roperation%last
                               crep%roperation%last%prev => crep%roperation%first
                               crep%coperation => crep%roperation
                               do ii=1,xml%no_attribs
                                  if (trim(xml%attribs(1,ii)).eq."filter") then
                                  else
                                     write(*,*)myname,'Unknown attribute:',&
                                          & trim(xml%tag)//':'//trim(xml%attribs(1,ii))
                                     irc=814
                                     return
                                  end if
                               end do
                            end if
                            if (xml%starttag.and.xml%endtag) then ! this is a filter
                               crep%roperation%type=opr_filter ! filter
                               do ii=1,xml%no_attribs
                                  call replaceENV(xml%attribs(2,ii),irc)
                                  if (irc.ne.0) then
                                     write(*,*)myname,'Error return from replaceEnv.',irc
                                     return
                                  end if
                                  len2=length(xml%attribs(2,ii),700,10)    
                                  if (trim(xml%attribs(1,ii)).eq."filter") then
                                     if (bdeb) write(*,*)myname,'Filter name:',xml%attribs(2,ii)(1:len2)
                                     ! find filter
                                     nullify(nfilter)
                                     cfilter => crep%firstfilter%next
                                     do while (.not.associated(cfilter, &
                                          & target=crep%lastfilter))
                                        if (trim(cfilter%name250).eq.&
                                             & xml%attribs(2,ii)(1:len2)) then
                                           nfilter => cfilter
                                           cfilter => crep%lastfilter
                                        else
                                           cfilter=>cfilter%next
                                        end if
                                     end do
                                     if (associated(nfilter)) then
                                        write(*,*) myname,'Using filter:',&
                                             & trim(nfilter%name250)
                                     end if
                                     crep%roperation%name250=xml%attribs(2,ii)(1:len2)
                                     crep%roperation%f => nfilter
                                     nullify(nfilter)
                                  else if (trim(xml%attribs(1,ii)).eq."override") then
                                     !              else if (trim(xml%attribs(1,ii)).eq."file") then
                                     !                 write(*,*)myname,'Filter file:',xml%attribs(2,ii)(1:len2)
                                     !                 ! make new filter and link to it
                                     !                 allocate(nfilter,stat=irc)
                                     !                 if (irc.ne.0) then
                                     !                    write(*,*) myname,'Unable to allocate filter.', irc
                                     !                    return
                                     !                 end if
                                     !                 nfilter%file250=xml%attribs(2,ii)(1:len2)
                                     !                 call readFilter(crep,nfilter,irc)
                                     !                 if (irc.ne.0) then
                                     !                    write(*,*)myname,'Error return from READFILTER.',irc
                                     !                    return
                                     !                 end if
                                     !                 crep%roperation%f => nfilter
                                     !                 nfilter%prev => crep%lastfilter%prev
                                     !                 nfilter%next => crep%lastfilter
                                     !                 crep%lastfilter%prev%next => nfilter
                                     !                 crep%lastfilter%prev => nfilter
                                     !                 nullify(nfilter)
                                  end if
                               end do
                            else
                               crep%roperation%type=opr_union ! empty container is treated as union
                               ! read until xml%endtag is reached
                               OP: do while (.not. (trim(xml%tag).eq."mask".and.xml%endtag.and. &
                                    & associated(crep%coperation,target=crep%roperation)))
                                  call xml_get( xml%info, xml%tag, xml%starttag, xml%endtag, &
                                       & xml%attribs, xml%no_attribs, xml%data, xml%no_data )
                                  if ( .not. xml_ok(xml%info) ) exit OP
                                  if (bdeb) write(*,*)myname,'Found MASK xml%tag:',&
                                       & trim(xml%tag),xml%starttag,xml%endtag
                                  if (trim(xml%tag).eq."intersection") then
                                     if (xml%starttag .and. .not.xml%endtag) then ! ignore empty intersections
                                        ! create new intersection-operation
                                        allocate(noperation,stat=irc) ! allocate new intersection
                                        if (irc.ne.0) then
                                           write(*,*)myname,'Unable to allocate operation.',irc
                                           return
                                        end if
                                        allocate(noperation%first,noperation%last,&
                                             & noperation%prev,noperation%next,stat=irc)
                                        if (irc.ne.0) then
                                           write(*,*)myname,'Unable to allocate operation chain.',irc
                                           return
                                        end if
                                        noperation%first%next => noperation%last
                                        noperation%last%prev => noperation%first
                                        noperation%type=opr_inter ! intersection
                                        if (.not. associated(crep%coperation)) then
                                           write(*,*)myname,'Current operation is not associated...'
                                           irc=935
                                           return
                                        end if
                                        noperation%parent => crep%coperation
                                        noperation%prev => crep%coperation%last%prev
                                        noperation%next => crep%coperation%last
                                        crep%coperation%last%prev%next => noperation
                                        crep%coperation%last%prev => noperation
                                        crep%coperation => noperation
                                        nullify(noperation)
                                     end if
                                     if (xml%endtag .and. .not.xml%starttag) then ! ignore empty intersections
                                        ! intersection completed
                                        if (crep%coperation%type.ne.opr_inter) then
                                           write(*,*)myname,'Closing union which is of invalid type:',&
                                                & crep%coperation%type
                                           irc=998
                                           return
                                        end if
                                        crep%coperation => crep%coperation%parent
                                     end if
                                  else if (trim(xml%tag).eq."union") then
                                     if (xml%starttag .and. .not.xml%endtag) then  ! ignore empty unions
                                        ! create new union-operation
                                        allocate(noperation,stat=irc) ! allocate new union
                                        if (irc.ne.0) then
                                           write(*,*)myname,'Unable to allocate operation.',irc
                                           return
                                        end if
                                        allocate(noperation%first,noperation%last,&
                                             & noperation%prev,noperation%next,stat=irc)
                                        if (irc.ne.0) then
                                           write(*,*)myname,'Unable to allocate operation chain.',irc
                                           return
                                        end if
                                        noperation%first%next => noperation%last
                                        noperation%last%prev => noperation%first
                                        noperation%type=opr_union ! union
                                        if (.not. associated(crep%coperation)) then
                                           write(*,*)myname,'Current operation is not associated...'
                                           irc=936
                                           return
                                        end if
                                        noperation%parent => crep%coperation
                                        noperation%prev => crep%coperation%last%prev
                                        noperation%next => crep%coperation%last
                                        crep%coperation%last%prev%next => noperation
                                        crep%coperation%last%prev => noperation
                                        crep%coperation => noperation
                                        nullify(noperation)
                                     end if
                                     if (.not.xml%starttag .and. xml%endtag) then  ! ignore empty unions
                                        ! union completed
                                        if (crep%coperation%type.ne.opr_union) then
                                           write(*,*)myname,'Closing union which is of invalid type:',&
                                                & crep%coperation%type
                                           irc=998
                                           return
                                        end if
                                        crep%coperation => crep%coperation%parent
                                     end if
                                  else if (trim(xml%tag).eq."mask") then
                                     if (xml%starttag) then
                                        ! new mask-operation
                                        allocate(noperation,stat=irc) ! allocate new use
                                        if (irc.ne.0) then
                                           write(*,*)myname,'Unable to allocate operation.',irc
                                           return
                                        end if
                                        allocate(noperation%first,noperation%last,&
                                             & noperation%prev,noperation%next,stat=irc)
                                        if (irc.ne.0) then
                                           write(*,*)myname,'Unable to allocate operation chain.',irc
                                           return
                                        end if
                                        noperation%first%next => noperation%last
                                        noperation%last%prev => noperation%first
                                        noperation%type=opr_filter ! mask
                                        if (.not. associated(crep%coperation)) then
                                           write(*,*)myname,'Current operation is not associated...'
                                           irc=937
                                           return
                                        end if
                                        do ii=1,xml%no_attribs
                                           call replaceENV(xml%attribs(2,ii),irc)
                                           if (irc.ne.0) then
                                              write(*,*)myname,'Error return from replaceEnv.',irc
                                              return
                                           end if
                                           len2=length(xml%attribs(2,ii),700,10)    
                                           if (trim(xml%attribs(1,ii)).eq."filter") then
                                              if (bdeb) write(*,*)myname,'Filter name:',&
                                                   & xml%attribs(2,ii)(1:len2)
                                              ! find filter
                                              nullify(nfilter)
                                              cfilter => crep%firstfilter%next
                                              do while (.not.associated(cfilter, target=crep%lastfilter))
                                                 if (trim(cfilter%name250).eq.&
                                                      & xml%attribs(2,ii)(1:len2)) then
                                                    nfilter => cfilter
                                                    cfilter => crep%lastfilter
                                                 else
                                                    cfilter=>cfilter%next
                                                 end if
                                              end do
                                              noperation%f => nfilter
                                              noperation%name250=xml%attribs(2,ii)(1:len2)
                                              nullify(nfilter)
                                              !                       else if (trim(xml%attribs(1,ii)).eq."file") then
                                              !                          write(*,*)myname,'Filter file:',xml%attribs(2,ii)(1:len2)
                                              !                          ! make new filter and link to it
                                              !                          allocate(nfilter,stat=irc)
                                              !                          if (irc.ne.0) then
                                              !                             write(*,*) myname,'Unable to allocate filter.', irc
                                              !                             return
                                              !                          end if
                                              !                          nfilter%file250=xml%attribs(2,ii)(1:len2)
                                              !                          call readFilter(crep,nfilter,irc)
                                              !                          if (irc.ne.0) then
                                              !                             write(*,*)myname,'Error return from READFILTER.',irc
                                              !                             return
                                              !                          end if
                                              !                          noperation%f => nfilter
                                              !                          nfilter%prev => crep%lastfilter%prev
                                              !                          nfilter%next => crep%lastfilter
                                              !                          crep%lastfilter%prev%next => nfilter
                                              !                          crep%lastfilter%prev => nfilter
                                              !                          nullify(nfilter)
                                           else
                                              write(*,*)myname,'Unknown attribute:',&
                                                   & trim(xml%tag)//':'//&
                                                   & trim(xml%attribs(1,ii))
                                              irc=815
                                              return
                                           end if
                                        end do
                                        noperation%parent => crep%coperation
                                        noperation%prev => crep%coperation%last%prev
                                        noperation%next => crep%coperation%last
                                        crep%coperation%last%prev%next => noperation
                                        crep%coperation%last%prev => noperation
                                        nullify(noperation)
                                     end if
                                  end if
                               end do OP
                            end if
                         else if (trim(xml%tag).ne."report".and.trim(xml%tag).ne."--") then
                            write(*,*)myname,'Unknown xml%tag B:',trim(xml%tag)
                            irc=931
                            return
                         else if (trim(xml%tag).eq."report".and.xml%endtag) then ! last REP
                            ! XML must contain: start, stop, issued and expires...
                            call addXML(crep,"start","@start@")
                            call addXML(crep,"stop","@stop@")
                            call addXML(crep,"issued","@issued@")
                            call addXML(crep,"expires","@expires@")
                            ! complete report...
                         end if
                      end do REP
                      !write(*,*)myname,'Adding report:',associated(cpar),associated(crep)
                      call addReport(cpar,crep,irc)
                      if (irc.ne.0) then
                         write(*,*)myname,'Error return from addReport.',irc
                         return
                      end if
                   end if
                end do PARR
                call addParameter(file,cpar,irc)
                if (irc.ne.0) then
                   write(*,*)myname,'Error return from addParameter.',irc
                   return
                end if
                nullify(cpar)
             else if (trim(xml%tag).ne."file".and.trim(xml%tag).ne."--") then
                write(*,*)myname,'Unknown xml%tag A:',trim(xml%tag)
                irc=930
                return
             end if
          end do INPUT
       else if (trim(xml%tag).ne."--") then
          write(*,*)myname,'Unknown xml%tag F:',trim(xml%tag)
          irc=938
          return
       end if
    enddo XMLL
    call xml_close( xml%info )
    !
    call chop0(file%nco350,350)
    call chop0(file%iter80,80)
    file%leni=length(file%iter80,80,0)
    !
    return
  end subroutine readXmlFile
  !
  subroutine  setKeyVar(file,mkey,par350,key350)
    implicit none
    type(filetype) :: file
    integer yy,mm,dd,hh,mi
    real sec
    character*24 a24
    character*4 ayy
    character*2 amm,add,ahh
    integer :: mkey
    character*350 par350,key350(mkey)
    real xissued
    CHARACTER*12 MYNAME
    DATA MYNAME /'setKeyVar'/
    call dj2000(file%a2000,yy,mm,dd,hh,mi,sec)
    xissued=f1970(yy,mm,dd,hh,mi,sec)
    write (a24,'(I4.4,"-",I2.2,"-",I2.2,"_",I2.2,"-",I2.2,"-00.000Z")') yy,mm,dd,hh,mi
    write (ayy,'(I4.4)') yy
    write (amm,'(I2.2)') mm
    write (add,'(I2.2)') dd
    write (ahh,'(I2.2)') hh
    key350(key_issued)=a24                           ! analysis time
    call chop0(key350(key_issued),350)
    key350(key_issued_yy)=ayy
    call chop0(key350(key_issued_yy),350)
    key350(key_issued_mm)=amm
    call chop0(key350(key_issued_mm),350)
    key350(key_issued_dd)=add
    call chop0(key350(key_issued_dd),350)
    key350(key_issued_hh)=ahh
    call chop0(key350(key_issued_hh),350)
    write(key350(key_issued_epoch),'(I0,"000")')nint(xissued)! analysis epoch
    call chop0(key350(key_issued_epoch),350)
    key350(key_par_name)=par350
    call chop0(key350(key_par_name),350)
    return
  end subroutine setKeyVar
  !
  subroutine setXmlVar(cpar,crep,file,mxml,mtim,mpst,xml350)
    implicit none
    type(parameter), pointer :: cpar
    type(report), pointer :: crep
    type(filetype) :: file
    integer :: mxml,mtim,mpst
    character*350 xml350(mxml,mtim,mpst)
    integer :: tmin,tmax
    real :: cauxmin,cauxmax
    integer yy,mm,dd,hh,mi
    real sec,cstart2000,cstop2000
    character*24 a24,x24,y24
    character*4 ayy
    character*2 amm,add,ahh
    character*700 :: b700
    real dta,dtad,dtah
    real :: cvalmin,cvalmax,cllmin(2),cllmax(2),ctmin2000,ctmax2000
    real xissued,xstart,xstop
    CHARACTER*12 MYNAME
    DATA MYNAME /'setXmlVar'/
    call dj2000(file%a2000,yy,mm,dd,hh,mi,sec)
    xissued=f1970(yy,mm,dd,hh,mi,sec)
    write (a24,'(I4.4,"-",I2.2,"-",I2.2,"_",I2.2,"-",I2.2,"-00.000Z")') yy,mm,dd,hh,mi
    write (ayy,'(I4.4)') yy
    write (amm,'(I2.2)') mm
    write (add,'(I2.2)') dd
    write (ahh,'(I2.2)') hh

    b700=cpar%var%var250
    call chop0(b700,700)
    lenb=length(b700,700,10)
    tmin=-1
    tmax=-1
    do ii=1,mpst
       do tt=1,mtim
          if (.not.crep%lfirst(tt,ii)) then ! no field available
             tmin=tt
             cvalmin=crep%valmin(tt,ii)
             cllmin(1)=crep%llmin(1,tt,ii)
             cllmin(2)=crep%llmin(2,tt,ii)
             ctmin2000=max(file%mint2000,crep%tj2000(tt)-cpar%hrs/(24.0D0*2.0D0))
             cvalmax=crep%valmax(tt,ii)
             cllmax(1)=crep%llmax(1,tt,ii)
             cllmax(2)=crep%llmax(2,tt,ii)
             ctmax2000=max(file%mint2000,crep%tj2000(tt)-cpar%hrs/(24.0D0*2.0D0))
             cstart2000=max(file%mint2000,crep%tj2000(tt)-file%dt-cpar%hrs/(24.0D0))
             cstop2000=crep%tj2000(tt)+file%dt
             if (crep%laux) then
                cauxmin=crep%auxmin(tt,ii)
                cauxmax=crep%auxmax(tt,ii)
             end if
             call dj2000(cstart2000,yy,mm,dd,hh,mi,sec)
             write (x24,'(I4.4,"-",I2.2,"-",I2.2,"_",I2.2,"-",I2.2,"-00.0000")') &
                  & yy,mm,dd,hh,mi
             xstart=f1970(yy,mm,dd,hh,mi,sec)
             call dj2000(cstop2000,yy,mm,dd,hh,mi,sec)
             write (y24,'(I4.4,"-",I2.2,"-",I2.2,"_",I2.2,"-",I2.2,"-00.0000")') &
                  & yy,mm,dd,hh,mi
             xstop=f1970(yy,mm,dd,hh,mi,sec)
             xml350(xml_issued,tt,ii)=a24                           ! analysis time
             call chop0(xml350(xml_issued,tt,ii),350)
             xml350(xml_issued_yy,tt,ii)=ayy
             call chop0(xml350(xml_issued_yy,tt,ii),350)
             xml350(xml_issued_mm,tt,ii)=amm
             call chop0(xml350(xml_issued_mm,tt,ii),350)
             xml350(xml_issued_dd,tt,ii)=add
             call chop0(xml350(xml_issued_dd,tt,ii),350)
             xml350(xml_issued_hh,tt,ii)=ahh
             call chop0(xml350(xml_issued_hh,tt,ii),350)
             write(xml350(xml_issued_epoch,tt,ii),'(I0,"000")')nint(xissued)! analysis epoch
             call chop0(xml350(xml_issued_epoch,tt,ii),350)
             write(xml350(xml_start_epoch,tt,ii),'(I0,"000")')nint(xstart)! start epoch
             call chop0(xml350(xml_start_epoch,tt,ii),350)
             write(xml350(xml_stop_epoch,tt,ii),'(I0,"000")')nint(xstop)  ! stop epoch
             call chop0(xml350(xml_stop_epoch,tt,ii),350)
             xml350(xml_start,tt,ii) =x24                           ! start date
             call chop0(xml350(xml_start,tt,ii),350)
             xml350(xml_stop,tt,ii)  =y24                           ! stop date
             call chop0(xml350(xml_stop,tt,ii),350)
             xml350(xml_expires,tt,ii)=file%t24                          ! expire time
             call chop0(xml350(xml_expires,tt,ii),350)
             !write(xml350(xml_start,tt,ii),'(F12.2)') (cstart2000-t2000)*24.0 ! forecast start in hours
             !write(xml350(xml_stop,tt,ii),'(F12.2)')  (cstop2000-t2000)*24.0 ! forecast stop in hours
             call dj2000(ctmin2000,yy,mm,dd,hh,mi,sec)
             write (x24,'(I4.4,"-",I2.2,"-",I2.2,"_",I2.2,"-",I2.2,"-00.0000")') &
                  & yy,mm,dd,hh,mi
             xml350(xml_minval_time,tt,ii) =x24                                          ! forecast start
             call chop0(xml350(xml_minval_time,tt,ii),350)
             dta=ctmin2000-file%a2000
             dtad=int(dta)
             dtah=(dta-dtad)*24.0D0
             write(xml350(xml_minval_dt,tt,ii),"(I0)") nint(dta*24.0D0)
             call chop0(xml350(xml_minval_dt,tt,ii),350)
             if (dtad.gt.0.0D0.and.dtah.gt.0.0D0) then
                write(xml350(xml_minval_dc,tt,ii),&
                     & '("+",I0,"d",I0,"h")') nint(dtad),nint(dtah)
             else if (dtad.gt.0.0D0) then
                write(xml350(xml_minval_dc,tt,ii),'("+",I0,"d")') nint(dtad)
             else
                write(xml350(xml_minval_dc,tt,ii),'("+",I0,"h")') nint(dtah)
             end if
             call chop0(xml350(xml_minval_dc,tt,ii),350)
             write(xml350(xml_minval_yy,tt,ii),"(I4.4)") yy
             call chop0(xml350(xml_minval_yy,tt,ii),350)
             write(xml350(xml_minval_mm,tt,ii),"(I2.2)") mm
             call chop0(xml350(xml_minval_mm,tt,ii),350)
             write(xml350(xml_minval_dd,tt,ii),"(I2.2)") dd
             call chop0(xml350(xml_minval_dd,tt,ii),350)
             write(xml350(xml_minval_hh,tt,ii),"(I2.2)") hh
             call chop0(xml350(xml_minval_hh,tt,ii),350)
             call dj2000(ctmax2000,yy,mm,dd,hh,mi,sec)
             write (y24,'(I4.4,"-",I2.2,"-",I2.2,"_",I2.2,"-",I2.2,"-00.0000")') &
                  & yy,mm,dd,hh,mi
             xml350(xml_maxval_time,tt,ii)  =y24                                          ! forecast stop
             call chop0(xml350(xml_maxval_time,tt,ii),350)
             dta=ctmax2000-file%a2000
             dtad=int(dta)
             dtah=(dta-dtad)*24.0D0
             write(xml350(xml_maxval_dt,tt,ii),"(I0)") nint(dta*24.0D0)
             call chop0(xml350(xml_maxval_dt,tt,ii),350)
             if (dtad.gt.0.0D0.and.dtah.gt.0.0D0) then
                write(xml350(xml_maxval_dc,tt,ii),&
                     & '("+",I0,"d",I0,"h")') nint(dtad),nint(dtah)
             else if (dtad.gt.0.0D0) then
                write(xml350(xml_maxval_dc,tt,ii),'("+",I0,"d")') nint(dtad)
             else
                write(xml350(xml_maxval_dc,tt,ii),'("+",I0,"h")') nint(dtah)
             end if
             call chop0(xml350(xml_maxval_dc,tt,ii),350)
             write(xml350(xml_maxval_yy,tt,ii),"(I4.4)") yy
             call chop0(xml350(xml_maxval_yy,tt,ii),350)
             write(xml350(xml_maxval_mm,tt,ii),"(I2.2)") mm
             call chop0(xml350(xml_maxval_mm,tt,ii),350)
             write(xml350(xml_maxval_dd,tt,ii),"(I2.2)") dd
             call chop0(xml350(xml_maxval_dd,tt,ii),350)
             write(xml350(xml_maxval_hh,tt,ii),"(I2.2)") hh
             call chop0(xml350(xml_maxval_hh,tt,ii),350)
             write(xml350(xml_acc_hh,tt,ii),"(F10.2)") cpar%hrs
             call chop0(xml350(xml_acc_hh,tt,ii),350)
             write(xml350(xml_minval,tt,ii),'(F12.2)') cvalmin       ! minimum value
             call chop0(xml350(xml_minval,tt,ii),350)
             write(xml350(xml_minval_lat,tt,ii),'(F12.2)') cllmin(1) ! minimum value lat
             call chop0(xml350(xml_minval_lat,tt,ii),350)
             write(xml350(xml_minval_lon,tt,ii),'(F12.2)') cllmin(2) ! minimum value lon
             call chop0(xml350(xml_minval_lon,tt,ii),350)
             write(xml350(xml_maxval,tt,ii),'(F12.2)') cvalmax       ! maximum value
             call chop0(xml350(xml_maxval,tt,ii),350)
             write(xml350(xml_maxval_lat,tt,ii),'(F12.2)') cllmax(1) ! minimum value lat
             call chop0(xml350(xml_maxval_lat,tt,ii),350)
             write(xml350(xml_maxval_lon,tt,ii),'(F12.2)') cllmax(2) ! minimum value lon
             call chop0(xml350(xml_maxval_lon,tt,ii),350)
             if (crep%laux) then
                write(xml350(xml_minaux,tt,ii),'(F12.2)') cauxmin ! minimum auxiliary value
                write(xml350(xml_maxaux,tt,ii),'(F12.2)') cauxmax ! maximum auxiliary value
             else
                xml350(xml_minaux,tt,ii)="NA"
                xml350(xml_maxaux,tt,ii)="NA"
             end if
             call chop0(xml350(xml_minaux,tt,ii),350)
             call chop0(xml350(xml_maxaux,tt,ii),350)
             tmin=-1
             tmax=-1
          end if
       end do
    end do
    return
  end subroutine setXmlVar
  !
  logical function getVarEnv(var,val50)
    implicit none
    character(*) :: var
    character*50 :: val50
    integer, parameter :: menv=10
    integer :: nenv=0
    call getenv(var,val50)
    getVarEnv=(len_trim(val50).ne.0)
    return
  end function getVarEnv
  !
  subroutine replaceEnv(str,irc)
    implicit none
    character*(*) str
    integer irc
    character*700 :: i700,b700
    integer :: leno,opos,cpos,lens,leni,leny
    integer, external :: length
    character*50 :: bal50
    CHARACTER*12 MYNAME
    DATA MYNAME /'replaceENV'/
    leno=0
    opos=1
    cpos=1
    lens=len(str)
    i700=str
    call chop0(i700,700)
    leni=length(i700,700,20)
    do while (cpos.le.leni)
       if (i700(cpos:cpos).eq."$") then ! first "$"
          b700=b700(1:leno)//i700(opos:cpos-1)
          leno=leno+max(0,cpos-opos)
          ! find next "$" if any
          cpos=cpos+1
          opos=cpos
          do while (cpos.lt.leni.and.i700(cpos:cpos).ne."$") ! second "$"
             cpos=cpos+1
          end do
          ! get environment-variable i700(opos:cpos-1)
          if (getVarEnv(i700(opos:cpos-1),bal50)) then
             leny=len_trim(bal50)
             b700=b700(1:leno)//bal50(1:leny)
             leno=leno+max(0,leny)
             opos=cpos+1 ! point to character after "$"
          else
             irc=941
             write(*,*)myname,'*** Undefined ENVIRONMENT variable: "'//&
                  & i700(opos:cpos-1)//'"'
             opos=opos-1 ! reset opos to first "$"
          end if
       end if
       !write(*,*) myname,' BUFF:::',cpos,lenb,i700(cpos:cpos)
       cpos=cpos+1
    end do
    b700=b700(1:leno)//i700(opos:cpos-1) ! copy the rest
    leno=leno+max(0,cpos-opos)
    if(bdeb) write(*,*)myname,'Output: "'//b700(1:min(lens,leno))//'"',lens
    str=b700(1:min(lens,leno))
    call chop0(str,lens)
    return
  end subroutine replaceEnv
  !
  subroutine replaceXML(i700,mvar,var350)
    implicit none
    character*700 :: i700
    integer :: mvar
    character*350 :: var350(mvar)
    integer opos,cpos,leni,lenx,leny
    character*700 :: b700
    CHARACTER*12 MYNAME
    DATA MYNAME /'replaceXML'/
    lenx=0
    opos=1
    cpos=1
    call chop0(i700,700)
    leni=length(i700,700,20)
    ! write(*,*) myname,'BUFF:',b700(1:leni)
    ! do ll=1,mvar
    !    call chop0(var350(ll),350)
    !    leny=length(var350(ll),350,10)
    !    write(*,*)myname,'VAR:',ll,var350(ll)(1:leny)
    ! end do
    do while (cpos.le.leni)
       if (i700(cpos:cpos).eq."@") then ! first "$"
          b700=b700(1:lenx)//i700(opos:cpos-1)
          lenx=lenx+max(0,cpos-opos)
          ! find next "$" if any
          cpos=cpos+1
          opos=cpos
          do while (cpos.lt.leni.and.i700(cpos:cpos).ne."@") ! second "$"
             cpos=cpos+1
          end do
          if (i700(opos:cpos-1).eq."issued") then
             leny=length(var350(xml_issued),350,10)
             b700=b700(1:lenx)//var350(xml_issued)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."issued_yy") then
             leny=length(var350(xml_issued_yy),350,10)
             b700=b700(1:lenx)//var350(xml_issued_yy)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."issued_mm") then
             leny=length(var350(xml_issued_mm),350,10)
             b700=b700(1:lenx)//var350(xml_issued_mm)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."issued_dd") then
             leny=length(var350(xml_issued_dd),350,10)
             b700=b700(1:lenx)//var350(xml_issued_dd)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."issued_hh") then
             leny=length(var350(xml_issued_hh),350,10)
             b700=b700(1:lenx)//var350(xml_issued_hh)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."issued_epoch") then
             leny=length(var350(xml_issued_epoch),350,10)
             b700=b700(1:lenx)//var350(xml_issued_epoch)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."start_epoch") then
             leny=length(var350(xml_start_epoch),350,10)
             b700=b700(1:lenx)//var350(xml_start_epoch)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."stop_epoch") then
             leny=length(var350(xml_stop_epoch),350,10)
             b700=b700(1:lenx)//var350(xml_stop_epoch)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."start") then
             leny=length(var350(xml_start),350,10)
             b700=b700(1:lenx)//var350(xml_start)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."stop") then
             leny=length(var350(xml_stop),350,10)
             b700=b700(1:lenx)//var350(xml_stop)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."expires") then
             leny=length(var350(xml_expires),350,10)
             b700=b700(1:lenx)//var350(xml_expires)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."minval") then
             leny=length(var350(xml_minval),350,10)
             b700=b700(1:lenx)//var350(xml_minval)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."minval_lat") then
             leny=length(var350(xml_minval_lat),350,10)
             b700=b700(1:lenx)//var350(xml_minval_lat)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."minval_lon") then
             leny=length(var350(xml_minval_lon),350,10)
             b700=b700(1:lenx)//var350(xml_minval_lon)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."minval_time") then
             leny=length(var350(xml_minval_time),350,10)
             b700=b700(1:lenx)//var350(xml_minval_time)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."minval_dt") then
             leny=length(var350(xml_minval_dt),350,10)
             b700=b700(1:lenx)//var350(xml_minval_dt)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."minval_dc") then
             leny=length(var350(xml_minval_dc),350,10)
             b700=b700(1:lenx)//var350(xml_minval_dc)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."minval_yy") then
             leny=length(var350(xml_minval_yy),350,10)
             b700=b700(1:lenx)//var350(xml_minval_yy)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."minval_mm") then
             leny=length(var350(xml_minval_mm),350,10)
             b700=b700(1:lenx)//var350(xml_minval_mm)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."minval_dd") then
             leny=length(var350(xml_minval_dd),350,10)
             b700=b700(1:lenx)//var350(xml_minval_dd)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."minval_hh") then
             leny=length(var350(xml_minval_hh),350,10)
             b700=b700(1:lenx)//var350(xml_minval_hh)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."maxval") then
             leny=length(var350(xml_maxval),350,10)
             b700=b700(1:lenx)//var350(xml_maxval)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."maxval_lat") then
             leny=length(var350(xml_maxval_lat),350,10)
             b700=b700(1:lenx)//var350(xml_maxval_lat)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."maxval_lon") then
             leny=length(var350(xml_maxval_lon),350,10)
             b700=b700(1:lenx)//var350(xml_maxval_lon)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."maxval_time") then
             leny=length(var350(xml_maxval_time),350,10)
             b700=b700(1:lenx)//var350(xml_maxval_time)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."maxval_dt") then
             leny=length(var350(xml_maxval_dt),350,10)
             b700=b700(1:lenx)//var350(xml_maxval_dt)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."maxval_dc") then
             leny=length(var350(xml_maxval_dc),350,10)
             b700=b700(1:lenx)//var350(xml_maxval_dc)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."maxval_yy") then
             leny=length(var350(xml_maxval_yy),350,10)
             b700=b700(1:lenx)//var350(xml_maxval_yy)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."maxval_mm") then
             leny=length(var350(xml_maxval_mm),350,10)
             b700=b700(1:lenx)//var350(xml_maxval_mm)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."maxval_dd") then
             leny=length(var350(xml_maxval_dd),350,10)
             b700=b700(1:lenx)//var350(xml_maxval_dd)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."maxval_hh") then
             leny=length(var350(xml_maxval_hh),350,10)
             b700=b700(1:lenx)//var350(xml_maxval_hh)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."accumulation_hours") then
             leny=length(var350(xml_acc_hh),350,10)
             b700=b700(1:lenx)//var350(xml_acc_hh)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."maxaux") then
             leny=length(var350(xml_maxaux),350,10)
             b700=b700(1:lenx)//var350(xml_maxaux)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."minaux") then
             leny=length(var350(xml_minaux),350,10)
             b700=b700(1:lenx)//var350(xml_minaux)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."iter") then
             leny=length(var350(xml_iter),350,10)
             b700=b700(1:lenx)//var350(xml_iter)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else  
             opos=opos-1 ! reset opos to first "@"
          end if
       end if
       !write(*,*) myname,' BUFF:::',cpos,leni,i700(cpos:cpos)
       cpos=cpos+1
    end do
    b700=b700(1:lenx)//i700(opos:cpos-1) ! copy the rest
    lenx=lenx+max(0,cpos-opos)
    i700=b700(1:lenx)
    call chop0(i700,700)
    return
  end subroutine replaceXML
  !
  !  
  subroutine replaceKEY(i700,mvar,var350)
    implicit none
    character*700 :: i700
    integer :: mvar
    character*350 :: var350(mvar)
    integer opos,cpos,lenb,lenx,leny
    character*700 :: b700
    CHARACTER*12 MYNAME
    DATA MYNAME /'replaceKey'/
    lenx=0
    opos=1
    cpos=1
    call chop0(i700,700)
    lenb=length(i700,700,20)
    ! write(*,*) myname,'BUFF:',i700(1:lenb)
    ! do ll=1,mvar
    !    call chop0(var350(ll),350)
    !    leny=length(var350(ll),350,10)
    !    write(*,*)myname,'VAR:',ll,var350(ll)(1:leny)
    ! end do
    do while (cpos.le.lenb)
       if (i700(cpos:cpos).eq."@") then ! first "$"
          b700=b700(1:lenx)//i700(opos:cpos-1)
          lenx=lenx+max(0,cpos-opos)
          ! find next "$" if any
          cpos=cpos+1
          opos=cpos
          do while (cpos.lt.lenb.and.i700(cpos:cpos).ne."@") ! second "$"
             cpos=cpos+1
          end do
          if (i700(opos:cpos-1).eq."issued") then
             leny=length(var350(key_issued),350,10)
             b700=b700(1:lenx)//var350(key_issued)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."issued_yy") then
             leny=length(var350(key_issued_yy),350,10)
             b700=b700(1:lenx)//var350(key_issued_yy)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."issued_mm") then
             leny=length(var350(key_issued_mm),350,10)
             b700=b700(1:lenx)//var350(key_issued_mm)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."issued_dd") then
             leny=length(var350(key_issued_dd),350,10)
             b700=b700(1:lenx)//var350(key_issued_dd)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."issued_hh") then
             leny=length(var350(key_issued_hh),350,10)
             b700=b700(1:lenx)//var350(key_issued_hh)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."issued_epoch") then
             leny=length(var350(key_issued_epoch),350,10)
             b700=b700(1:lenx)//var350(key_issued_epoch)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else if (i700(opos:cpos-1).eq."par_name") then
             leny=length(var350(key_par_name),350,10)
             b700=b700(1:lenx)//var350(key_par_name)(1:leny)
             lenx=lenx+max(0,leny)
             opos=cpos+1 ! point to character after "@"
          else  
             opos=opos-1 ! reset opos to first "@"
          end if
       end if
       !write(*,*) myname,' BUFF:::',cpos,lenb,i700(cpos:cpos)
       cpos=cpos+1
    end do
    b700=b700(1:lenx)//i700(opos:cpos-1) ! copy the rest
    lenx=lenx+max(0,cpos-opos)
    i700=b700(1:lenx)
    call chop0(i700,700)
    return
  end subroutine replaceKEY
  !
  recursive function checkMasked(op,lat,lon,ialt,irc) result(res)
    implicit none
    logical :: res
    type(operation), pointer :: op
    real lat
    real lon
    real ialt
    integer irc
    !
    real val,minlat,maxlat,minlon,maxlon
    type(operation), pointer :: cop
    type(filter), pointer :: f
    logical inside, iflag
    integer inout, idim, ii
    real dx,dy,dz,ds,ws,hs,dd
    real alt, dist,maxalt,minalt
    CHARACTER*18 MYNAME
    DATA MYNAME /'checkMasked'/
    !
    alt=ialt
    select case (op%type)
    case (opr_inter) ! intersection
       res=.false.
       cop => op%first%next
       do while (.not.associated(cop,target=op%last))
          iflag=checkMasked(cop,lat,lon,alt,irc)
          if (irc.ne.0) then
             write(*,*) myname,'Error return from checkMasked.',irc
             return
          end if
          if (iflag) then
             res=.true.
             cop=>op%last
          else
             cop=>cop%next
          end if
       end do
    case (opr_union) ! union
       res=.true.
       cop => op%first%next
       do while (.not.associated(cop,target=op%last))
          iflag=checkMasked(cop,lat,lon,alt,irc)
          if (irc.ne.0) then
             write(*,*) myname,'Error return from checkMasked.',irc
             return
          end if
          if (.not.iflag) then
             res=.false.
          end if
          cop=>cop%next
       end do
    case (opr_filter) ! filter
       f => op%f
       if (.not.associated(f)) then
          res=.true.
          write(*,*) 'Missing filter:',trim(op%name250)
          irc=942
          return
       end if
       select case(f%type)
       case(flt_slice) ! slice
          res=.false.
          if (f%lpar(0)) then ! must initialise
             if (.not. f%lpar(3)) then ! we have 3D fields (with altitude)
                f%rpar(3)=0.0D0 ! no altitude
                f%rpar(7)=0.0D0 ! no altitude
                f%rpar(13)=0.0D0 ! no altitude
                f%rpar(17)=0.0D0 ! no altitude
             end if
             if (.not.res.and.f%lpar(1).and.f%lpar(2)) then ! we have origo
                f%rpar(20)= (re+f%rpar(3))*cosdeg(f%rpar(1))*cosdeg(f%rpar(2)) ! origo x
                f%rpar(21)= (re+f%rpar(3))*cosdeg(f%rpar(1))*sindeg(f%rpar(2)) ! origo y
                f%rpar(22)= (re+f%rpar(3))*sindeg(f%rpar(1))! origo z
                ! make normal...
                if (.not.res.and.f%lpar(15).and.f%lpar(16)) then ! we have a normal
                   f%rpar(23)= (re+f%rpar(17))*cosdeg(f%rpar(15))*cosdeg(f%rpar(16)) -f%rpar(20) ! x
                   f%rpar(24)= (re+f%rpar(17))*cosdeg(f%rpar(15))*sindeg(f%rpar(16)) -f%rpar(21) ! y
                   f%rpar(25)= (re+f%rpar(17))*sindeg(f%rpar(15)) -f%rpar(22) ! z
                   f%lpar(0)=.false. ! initialised
                else if (.not.res.and.f%lpar(5).and.f%lpar(6)) then ! we have abscissa
                   f%rpar(26)= (re+f%rpar(7))*cosdeg(f%rpar(5))*cosdeg(f%rpar(6)) -f%rpar(20) ! x
                   f%rpar(27)= (re+f%rpar(7))*cosdeg(f%rpar(5))*sindeg(f%rpar(6)) -f%rpar(21) ! y
                   f%rpar(28)= (re+f%rpar(7))*sindeg(f%rpar(5)) -f%rpar(22) ! z
                   if (.not.res.and.f%lpar(5).and.f%lpar(6)) then ! we have ordinate
                      f%rpar(29)= (re+f%rpar(13))*cosdeg(f%rpar(11))*cosdeg(f%rpar(12)) -f%rpar(20) ! x
                      f%rpar(30)= (re+f%rpar(13))*cosdeg(f%rpar(11))*sindeg(f%rpar(12)) -f%rpar(21) ! y
                      f%rpar(31)= (re+f%rpar(13))*sindeg(f%rpar(11)) -f%rpar(22) ! z
                   else ! origo and abscissa, but no ordinate
                      f%rpar(29)= 0.0D0
                      f%rpar(30)= 0.0D0
                      f%rpar(31)= -1.0D0
                   end if
                   ! calculate cross product
                   f%rpar(23)=f%rpar(27)*f%rpar(31)-f%rpar(28)*f%rpar(30)
                   f%rpar(24)=f%rpar(28)*f%rpar(29)-f%rpar(26)*f%rpar(31)
                   f%rpar(25)=f%rpar(26)*f%rpar(30)-f%rpar(27)*f%rpar(29)
                   f%lpar(0)=.false. ! initialised
                else ! origo, but no normal nor abscissa 
                   write(*,*)myname,'Missing normal/abscissa-parameter in SLICE-filter.'
                   irc=845
                   return
                end if
             else  ! no origo
                write(*,*)myname,'Missing origo-parameter in SLICE-filter.'
                irc=841
                return
             end if
          end if
          if (f%lpar(0)) then ! failed to initialise
             res=.true.
             write(*,*)myname,'Failed to initialise SLICE-filter.'
             irc=840
             return
          else
             if (.not.f%lpar(3)) then ! we have 3D fields (with altitude)
                alt=0.0D0
             end if
             dx= (re+alt)*cosdeg(lat)*cosdeg(lon) - f%rpar(20) ! pos x
             dy= (re+alt)*cosdeg(lat)*sindeg(lon) - f%rpar(21) ! pos y
             dz= (re+alt)*sindeg(lat) - f%rpar(22) ! origo z
             dd=dx*f%rpar(23)+dy*f%rpar(24)+dz*f%rpar(25)
             inside= (dd.ge.0.0D0)
             if ((f%inside.and..not.inside).or.(.not.f%inside.and.inside)) res=.true.
          end if
       case (flt_cylinder) ! cylinder
          res=.false.
          if (f%lpar(0)) then ! must initialise
             f%lpar(0)=.false. ! initialised
          end if
          if (.not.res.and.f%lpar(1).and.f%lpar(2).and.f%lpar(4)) then ! lat/lon/width
             dist=getdist(f%rpar(1),f%rpar(2),lat,lon)*40.0D6/360.0D0
             inside=(dist.lt.f%rpar(4)*0.5D0)
             if ((f%inside.and..not.inside).or.(.not.f%inside.and.inside)) res=.true.
          end if
          if (.not.res.and.f%lpar(3).and.f%lpar(5)) then ! alt/height
             maxalt=f%rpar(3)+f%rpar(5)*0.5D0
             minalt=f%rpar(3)-f%rpar(5)*0.5D0
             inside=(alt.le.maxalt .or. alt.ge.minalt)
             if ((f%inside.and..not.inside).or.(.not.f%inside.and.inside)) res=.true.
          end if
          !          if (.not.res) then
          !             write(*,*)myname,'Cylinder:',dist,f%rpar(4)*0.5D0,alt,maxalt,minalt,res
          !          end if
       case (flt_polygon)  ! polygon
          res=.false.
          if (f%lpar(0)) then ! must initialise
             f%lpar(0)=.false. ! initialised
          end if
          inout=-1 ! border=0, -1 outside, +1 inside
          minlat=f%rpar(f%mpar*2+1)
          maxlat=f%rpar(f%mpar*2+2)
          minlon=f%rpar(f%mpar*2+3)
          maxlon=f%rpar(f%mpar*2+4)
          if (isClose(lat,lon,minlat,maxlat,minlon,maxlon,f%delta)) then
             CALL PNPOLY (lat, lon, f%mpar, f%rpar(1), f%rpar(1+f%mpar), INOUT )
             !write(*,*)myname,'Polygon:',f%mpar,size(f%rpar),f%mpar*2+4,lat,lon,inout
             !inout=1
             if (f%ledge .and. inout.eq.-1) then ! check if inside edge...
                call checkEdge(lat, lon, f%mpar, f%rpar(1), f%rpar(1+f%mpar), f%delta, INOUT )
             end if
          end if
          inside=(inout.ne.-1)
          if ((f%inside.and..not.inside).or.(.not.f%inside.and.inside)) res=.true.
          !if (.not.res) then
          !   write(*,*)myname,'Polygon:',lat,lon,res
          !end if
       case (flt_duct) ! duct
          res=.false.
          if (f%lpar(0)) then ! must initialise
             if (.not. f%lpar(3)) then ! we have 3D fields (with altitude)
                f%rpar(3)=0.0D0 ! no altitude
                f%rpar(13)=0.0D0 ! no altitude
             end if
             if (.not.res.and.f%lpar(1).and.f%lpar(2).and.f%lpar(11).and.f%lpar(12)) then ! we have start/stop
                ! origo
                f%rpar(20)= (re+f%rpar(3))*cosdeg(f%rpar(1))*cosdeg(f%rpar(2)) ! x
                f%rpar(21)= (re+f%rpar(3))*cosdeg(f%rpar(1))*sindeg(f%rpar(2)) ! y
                f%rpar(22)= (re+f%rpar(3))*sindeg(f%rpar(1))! z
                ! make alongtrack vector (l=R1-R2)
                f%rpar(23)= (re+f%rpar(13))*cosdeg(f%rpar(11))*cosdeg(f%rpar(12)) -f%rpar(20) ! x
                f%rpar(24)= (re+f%rpar(13))*cosdeg(f%rpar(11))*sindeg(f%rpar(12)) -f%rpar(21) ! y
                f%rpar(25)= (re+f%rpar(13))*sindeg(f%rpar(11)) -f%rpar(22) ! z
                f%rpar(26)=sqrt(max(1.0D-5, f%rpar(23)*f%rpar(23)&
                     & + f%rpar(24)*f%rpar(24) + f%rpar(25)*f%rpar(25)))
                f%rpar(23)=f%rpar(23)/f%rpar(26)
                f%rpar(24)=f%rpar(24)/f%rpar(26)
                f%rpar(25)=f%rpar(25)/f%rpar(26)
                ! make radial vector (r=R/|R|)
                f%rpar(27)=f%rpar(20) ! x
                f%rpar(28)=f%rpar(21) ! y
                f%rpar(29)=f%rpar(22) ! z
                f%rpar(30)=sqrt(max(1.0D-5, f%rpar(27)*f%rpar(27)&
                     & + f%rpar(28)*f%rpar(28)+f%rpar(29)*f%rpar(29)))
                f%rpar(27)=f%rpar(27)/f%rpar(30) ! x
                f%rpar(28)=f%rpar(28)/f%rpar(30) ! y
                f%rpar(29)=f%rpar(29)/f%rpar(30) ! z
                ! make cross track vector (c=lxr)
                f%rpar(31)=f%rpar(24)*f%rpar(29)-f%rpar(25)*f%rpar(28)
                f%rpar(32)=f%rpar(25)*f%rpar(27)-f%rpar(23)*f%rpar(29)
                f%rpar(33)=f%rpar(23)*f%rpar(28)-f%rpar(24)*f%rpar(27)
                f%rpar(34)=sqrt(max(1.0D-5, f%rpar(31)*f%rpar(31)&
                     & + f%rpar(32)*f%rpar(32)+f%rpar(33)*f%rpar(33)))
                f%rpar(31)=f%rpar(31)/f%rpar(34) ! x
                f%rpar(32)=f%rpar(32)/f%rpar(34) ! y
                f%rpar(33)=f%rpar(33)/f%rpar(34) ! z
                ! make vertical vector (v=lxc)
                f%rpar(35)=f%rpar(24)*f%rpar(33)-f%rpar(25)*f%rpar(32)
                f%rpar(36)=f%rpar(25)*f%rpar(31)-f%rpar(23)*f%rpar(33)
                f%rpar(37)=f%rpar(23)*f%rpar(32)-f%rpar(24)*f%rpar(31)
                f%rpar(38)=sqrt(max(1.0D-5, f%rpar(35)*f%rpar(35)&
                     & + f%rpar(36)*f%rpar(36)+f%rpar(37)*f%rpar(37)))
                f%rpar(35)=f%rpar(35)/f%rpar(38) ! x
                f%rpar(36)=f%rpar(36)/f%rpar(38) ! y
                f%rpar(37)=f%rpar(37)/f%rpar(38) ! z
                f%lpar(0)=.false. ! initialised
             else ! missing parameters
                write(*,*)myname,'Missing start/stop-parameter in DUCT-filter.'
                irc=845
                return
             end if
          end if
          if (f%lpar(0)) then ! failed to initialise
             res=.true.
             write(*,*)myname,'Failed to initialise DUCT-filter.'
             irc=840
             return
          else
             if (.not.f%lpar(3)) then ! we have 3D fields (with altitude)
                alt=0.0D0
             end if
             dx= (re+alt)*cosdeg(lat)*cosdeg(lon) - f%rpar(20) ! pos x
             dy= (re+alt)*cosdeg(lat)*sindeg(lon) - f%rpar(21) ! pos y
             dz= (re+alt)*sindeg(lat) - f%rpar(22) ! origo z
             ! along track
             ds=(dx*f%rpar(23)+dy*f%rpar(24)+dz*f%rpar(25))/f%rpar(26)
             inside= (ds.ge.0.0D0.and.ds.le.1.0D0)
             ! cross track
             if (inside) then
                ws=abs(dx*f%rpar(31)+dy*f%rpar(32)+dz*f%rpar(33))/ &
                     & ( (1.0D0-ds)*f%rpar(4)*0.5D0 + ds*f%rpar(14)*0.5D0 )
                if (ws.gt.1.0D0) inside=.false.
             end if
             ! vertical
             if (inside.and. f%lpar(3)) then
                hs=abs(dx*f%rpar(35)+dy*f%rpar(36)+dz*f%rpar(37))/ &
                     & ( (1.0D0-ds)*f%rpar(5)*0.5D0 + ds*f%rpar(15)*0.5D0 )
                if (hs.gt.1.0D0) inside=.false.
             end if
             if ((f%inside.and..not.inside).or.(.not.f%inside.and.inside)) res=.true.
          end if
       case (flt_value) ! parameter
          if (.not.associated(f%v)) then
             write(*,*) myname,'No variable associated with filter:',trim(f%name250)
             irc=458
             return
          end if
          val=ncf_valuePosition(f%v,irc)
          if (irc.ne.0) then
             write(*,*) myname,'Error return from ncf_valuePosition.',irc
             return
          end if
          res=.false.
          if (f%lpar(0)) then ! must initialise
             f%minval=val
             f%maxval=val
             f%lpar(0)=.false. ! initialised
          else
             f%minval=min(val,f%minval)
             f%maxval=max(val,f%maxval)
          end if
          if (.not.res.and.f%lpar(1)) then ! min threshold
             if (val.lt.f%rpar(1)) res=.true.
          end if
          if (.not.res.and.f%lpar(2)) then ! min threshold
             if (val.gt.f%rpar(2)) res=.true.
          end if
          !write(*,*)myname,'Value:',dist,f%rpar(4)*0.5D0,alt,maxalt,minalt,res
       case (flt_string) ! string
          if (.not.associated(f%v)) then
             write(*,*) myname,'No variable associated with filter:',trim(f%name250)
             irc=458
             return
          end if
          res=.false.
          !write(*,*)myname,'SDO:'
          !call ncf_printDimOrder(f%sdo)
          sval250=ncf_stringPosition250(f%v,f%sdo,irc)
          if (irc.ne.0) then
             write(*,*) myname,'Error return from ncf_stringPosition250.',irc
             return
          end if
          call chop0(sval250,250)
          lens=length(sval250,250,3)
          !write(*,*)myname,"Comparing: '"//sval250(1:lens)//"' '"//f%spar250(1:f%lens)//"'"
          if (.not.res.and.f%lpar(1)) then ! string
             if (sval250(1:lens).ne.f%spar250(1:f%lens)) res=.true.
          end if
          !write(*,*)myname,'Value:',dist,f%rpar(4)*0.5D0,alt,maxalt,minalt,res
       case (flt_dimension) ! dimension
          res=.false.
          if (f%lpar(0)) then ! initialise
             !write(*,*) 'Test:',ii,f%npar(0),trim(f%sdim80)
             f%npar(0)=ncf_getDimEntry(f%i,f%sdim80)
             if (f%npar(0).eq.0) then
                write(*,*) 'Undefined dimension:',trim(f%sdim80)
             end if
             f%lpar(0)=.false. ! initialised
          end if
          idim=f%i%pos%pos(f%npar(0))
          ! get dimension value
          if (idim.ne.-1) then ! defined
             if (f%lpar(1)) then ! min
                if (.not.res.and.idim.lt.f%npar(1)) res=.true.
             end if
             if (f%lpar(2)) then ! max
                if (.not.res.and.idim.gt.f%npar(2)) res=.true.
             end if
             !write(*,*)myname,'Checking:',idim,res,f%npar(1),f%npar(2),f%npar(0)
          end if
          !write(*,*) 'Test:',idim,res,f%npar(1),f%npar(2),f%npar(0),f%lpar(1),f%lpar(2)
       case DEFAULT
          write(*,*) 'Invalid filter type:',f%type,trim(op%name250)
          irc=941
          return
       end select
    case DEFAULT
       res=.true.
       write(*,*) 'Unknown type:',op%type
       irc=939
       return
    end select
    return
  end function checkMasked

  recursive subroutine setActive(op,irc)
    implicit none
    type(operation), pointer :: op
    integer irc
    !
    type(operation), pointer :: cop
    type(filter), pointer :: f
    CHARACTER*12 MYNAME
    DATA MYNAME /'setActive'/
    !
    if (associated(op)) then
       if (op%type .eq. 1 .or. op%type .eq. 2) then ! intersection/union
          cop => op%first%next
          do while (.not.associated(cop,target=op%last))
             call setActive(cop,irc)
             if (irc.ne.0) then
                write(*,*) myname,'Error return from setActive.',irc
                return
             end if
             cop=>cop%next
          end do
       else if (op%type .eq. 3) then ! mask operation
          f => op%f
          if (.not.associated(f)) then
             write(*,*) 'Missing mask filter:',trim(op%name250)
             irc=942
             return
          end if
          f%active=.true.
       else
          write(*,*) 'Unknown type:',op%type
          irc=939
          return
       end if
    end if
    return
  end subroutine setActive
  !     
  ! find closest i and j
  !     
  real function xycross(x1,y1,x2,y2,x3,y3)
    real :: x1,y1,x2,y2,x3,y3
    real :: dx1,dy1,dx2,dy2
    dx1=x3-x1
    dy1=y3-y1
    dx2=x2-x1
    dy2=y2-y1
    xycross = dx1 * dy2 - dx2 * dy1
  end function xycross

  real function degtor(x)
    implicit none
    real x
    real pi
    parameter (pi=3.14159265359)
    degtor=x*pi/180.
  end function degtor

  real function rtodeg(x)
    implicit none
    real x
    real pi
    parameter (pi=3.14159265359)
    rtodeg=x*180./pi
  end function rtodeg

  real function sindeg(x)
    implicit none
    real x,degtor
    sindeg=sin(degtor(x))
  end function sindeg

  real function cosdeg(x)
    implicit none
    real x,degtor
    cosdeg=cos(degtor(x))
  end function cosdeg

  real function tandeg(x)
    implicit none
    real x,degtor
    tandeg=tan(degtor(x))
  end function tandeg

  real function asindeg(x)
    implicit none
    real x,rtodeg
    asindeg=rtodeg(asin(x))
  end function asindeg

  real function acosdeg(x)
    implicit none
    real x,rtodeg
    acosdeg=rtodeg(acos(x))
  end function acosdeg

  real function atandeg(x)
    implicit none
    real x,rtodeg
    atandeg=rtodeg(atan(x))
  end function atandeg

  real function atan2deg(y,x)
    implicit none
    real y,x,rtodeg
    atan2deg=rtodeg(atan2(y,x))
  end function atan2deg

  function getDim(i,num)
    type(dimension), pointer :: getDim
    type(dimensionOrder) :: i
    integer num
    integer kk
    type(dimension), pointer :: d
    nullify(getDim)
    kk=0
    d=>i%firstDimension%next
    do while (.not.associated(d,i%lastDimension))
       kk=kk+1
       if (kk.eq.num) then
          getDim=>d
          d=>i%lastDimension
       else
          d=>d%next
       end if
    end do
  end function getDim

  subroutine interpolate2D(r,e,ix,iy,wgt,biok,irc)
    implicit none
    type(inventory) r
    type(inventory) e
    type(dimension) ix
    type(dimension) iy
    type(weight) wgt
    integer irc
    real :: xf,yf
    integer :: nxs,nys,nzs
    real :: xs(2,2), ys(2,2)
    logical :: biok, xok,yok
    logical :: bdone,bdeb, changed, inside
    real :: bc,rc,tc,lc,fc,tbc,lrc
    real :: brc,rtc,tlc,lbc
    integer :: jbc,jrc,jtc,jlc,jbrc,jrtc,jtlc,jlbc,ii,jj
    integer :: iterations = 0
    CHARACTER*14 MYNAME
    DATA MYNAME /'interpolate2D'/
    !e%pos%pos(ix%ind)=max(ix%sta,min(ix%lim-1,e%pos%pos(ix%ind)))
    !e%pos%pos(iy%ind)=max(iy%sta,min(iy%lim-1,e%pos%pos(iy%ind)))
    ! search for match where position is within gridcell
    xf=ncf_valuePosition(r%lonid,irc)
    if (irc.ne.0) then
       write(*,*)myname,'error return from ncf_valuePosition.',irc
       return
    end if
    yf=ncf_valuePosition(r%latid,irc)
    if (irc.ne.0) then
       write(*,*)myname,'error return from ncf_valuePosition.',irc
       return
    end if
    bdone=.false.
    bdeb=.false.
    ! iterations=0
    do while (.not. bdone)
       iterations=iterations+1
       xok=.true.
       yok=.true.
       xok=ncf_incrementDimension(e,ix,xok,1,0,irc) ! -> bottom right
       if (irc.ne.0) then
          write(*,*) myname,'Error return from incrementPosition.',irc
          return
       end if
       xs(2,1)=ncf_valuePosition(e%lonid,irc)
       if (irc.ne.0) then
          write(*,*) myname,'Error return from valuePosition (lonid).',irc
          return
       end if
       ys(2,1)=ncf_valuePosition(e%latid,irc)
       if (irc.ne.0) then
          write(*,*) myname,'Error return from valuePosition (latid).',irc
          return
       end if

       yok=ncf_incrementDimension(e,iy,yok,1,0,irc) ! -> top right
       if (irc.ne.0) then
          write(*,*) myname,'Error return from incrementPosition.',irc
          return
       end if
       xs(2,2)=ncf_valuePosition(e%lonid,irc)
       if (irc.ne.0) then
          write(*,*) myname,'Error return from valuePosition (lonid).',irc
          return
       end if
       ys(2,2)=ncf_valuePosition(e%latid,irc)
       if (irc.ne.0) then
          write(*,*) myname,'Error return from valuePosition (latid).',irc
          return
       end if

       xok=ncf_decrementDimension(e,ix,xok,1,0,irc) ! -> top left
       if (irc.ne.0) then
          write(*,*) myname,'Error return from decrementPosition.',irc
          return
       end if
       xs(1,2)=ncf_valuePosition(e%lonid,irc)
       if (irc.ne.0) then
          write(*,*) myname,'Error return from valuePosition (lonid).',irc
          return
       end if
       ys(1,2)=ncf_valuePosition(e%latid,irc)
       if (irc.ne.0) then
          write(*,*) myname,'Error return from valuePosition (latid).',irc
          return
       end if

       yok=ncf_decrementDimension(e,iy,yok,1,0,irc) ! -> bottom left
       if (irc.ne.0) then
          write(*,*) myname,'Error return from decrementPosition.',irc
          return
       end if
       xs(1,1)=ncf_valuePosition(e%lonid,irc)
       if (irc.ne.0) then
          write(*,*) myname,'Error return from valuePosition (lonid).',irc
          return
       end if
       ys(1,1)=ncf_valuePosition(e%latid,irc)
       if (irc.ne.0) then
          write(*,*) myname,'Error return from valuePosition (latid).',irc
          return
       end if

       if (.not. xok.or. .not.yok) then
          biok=.false.
          xok=ncf_decrementDimension(e,ix,xok,1,0,irc) ! -> top left
          if (irc.ne.0) then
             write(*,*) myname,'Error return from decrementPosition.',irc
             return
          end if
          yok=ncf_decrementDimension(e,iy,yok,1,0,irc) ! -> bottom left
          if (irc.ne.0) then
             write(*,*) myname,'Error return from decrementPosition.',irc
             return
          end if
          call printPos(e%pos)
          write(*,*)myname, 'Invalid starting position.'
          irc=956
          return
       else
          !write(*,*)'XS:',xf,xs
          !write(*,*)'YS:',yf,ys
          !call exit(0)

          ! walk around grid cell border and calculate cross product
          bc=xycross(xs(1,1),ys(1,1), xf,yf, xs(2,1),ys(2,1)) ! bottom
          rc=xycross(xs(2,1),ys(2,1), xf,yf, xs(2,2),ys(2,2)) ! right
          tc=xycross(xs(2,2),ys(2,2), xf,yf, xs(1,2),ys(1,2)) ! top
          lc=xycross(xs(1,2),ys(1,2), xf,yf, xs(1,1),ys(1,1)) ! left

          if (abs(bc).lt.1.0D-10) then
             jbc=0
          else
             jbc=nint(sign(1.0D0,bc))
          end if
          if (abs(rc).lt.1.0D-10) then
             jrc=0
          else
             jrc=nint(sign(1.0D0,rc))
          end if
          if (abs(tc).lt.1.0D-10) then
             jtc=0
          else
             jtc=nint(sign(1.0D0,tc))
          end if
          if (abs(lc).lt.1.0D-10) then
             jlc=0
          else
             jlc=nint(sign(1.0D0,lc))
          end if

          brc=xycross(xs(1,1),ys(1,1), xs(2,2),ys(2,2), xs(2,1),ys(2,1)) ! bottom-right
          rtc=xycross(xs(2,1),ys(2,1), xs(1,2),ys(1,2), xs(2,2),ys(2,2)) ! right-top
          tlc=xycross(xs(2,2),ys(2,2), xs(1,1),ys(1,1), xs(1,2),ys(1,2)) ! top-left
          lbc=xycross(xs(1,2),ys(1,2), xs(2,1),ys(2,1), xs(1,1),ys(1,1)) ! left-bottom

          jbrc=nint(sign(1.0D0,brc))
          jrtc=nint(sign(1.0D0,rtc))
          jtlc=nint(sign(1.0D0,tlc))
          jlbc=nint(sign(1.0D0,lbc))

          if (bdeb) then
             write(*,'("XYSEARCH ",2(3X,"(",4(X,F13.5),")"),2(3X,"(",4(X,I2),")"))') &
                  &bc,rc,tc,lc, brc,rtc,tlc,lbc,jbc,jrc,jtc,jlc, jbrc,jrtc,jtlc,jlbc
             write(*,'("XYSEARCH ",5(" (",F10.5,",",F10.5,")"))') &
                  & xf,yf, &
                  & xs(1,1),ys(1,1), &
                  & xs(2,1),ys(2,1), &
                  & xs(2,2),ys(2,2), &
                  & xs(1,2),ys(1,2)
          end if
          !     
          !     if cross product has same sign as axis-sign => inside, else outside
          !     (make sure we do not cross border while searching...)
          !     
          inside=.true.
          changed=.false.
          if (jbc.eq.-jbrc) then  ! decrease y
             if (ncf_decrementDimension(e,iy,yok,1,0, irc)) then
                changed=.true.

                !write(*,*)myname,'Y-',e%pos%pos(iy%ind),iterations,bc,brc

             end if
             if (irc.ne.0) then
                write(*,*) myname,'Error return from decrementPosition.',irc
                return
             end if
             inside=.false.
          else if (jtc.eq.-jtlc) then ! increase y
             if (ncf_incrementDimension(e,iy,yok,1,1, irc)) then
                changed=.true.


                !write(*,*)myname,'Y+',e%pos%pos(iy%ind),iterations,tc,tlc

             end if
             if (irc.ne.0) then
                write(*,*) myname,'Error return from incrementPosition.',irc
                return
             end if
             inside=.false.
          end if
          if (jlc.eq.-jlbc) then  ! decrease x
             if (ncf_decrementDimension(e,ix,xok,1,0, irc)) then
                changed=.true.

                !write(*,*)myname,'X-',e%pos%pos(ix%ind),iterations,lc,lbc

             end if
             if (irc.ne.0) then
                write(*,*) myname,'Error return from decrementPosition.',irc
                return
             end if
             inside=.false.
          else if (jrc.eq.-jrtc) then ! increase x
             if (ncf_incrementDimension(e,ix,xok,1,1, irc)) then
                changed=.true.

                !write(*,*)myname,'X+',e%pos%pos(ix%ind),iterations,rc,rtc

             end if
             if (irc.ne.0) then
                write(*,*) myname,'Error return from incrementPosition.',irc
                return
             end if
             inside=.false.
          end if
          if (inside) then       ! we are inside the cell
             biok=.true.
             bdone=.true.
             tbc=tc+bc
             lrc=lc+rc
             fc=(tbc*lrc)
             fc=max(fc,1.0D-10)
             if (abs(fc).lt.1.0D-10) then
                call printPos(e%pos)
                write(*,*) myname,'Invalid grid:',rc,tc,lc,bc,fc
                irc=957
                return
             end if
             wgt%w(1)=lc*tc/fc ! bottom right
             wgt%w(2)=lc*bc/fc ! top right
             wgt%w(3)=rc*bc/fc ! top left
             wgt%w(4)=rc*tc/fc ! bottom left
             ! store position vector
             do ii=1,wgt%nweight
                if (wgt%pos(ii)%maxdim .lt. e%pos%nrdim) then ! sufficient dimensions?
                   call allocatePos(e%pos%nrdim,wgt%pos(ii),irc)
                   if (irc.ne.0) then
                      write(*,*) myname,'Error return from allocatePos.',irc
                      return
                   end if
                else
                   wgt%pos(ii)%nrdim=e%pos%nrdim
                end if
                do jj=1,wgt%pos(ii)%nrdim
                   wgt%pos(ii)%pos(jj)=0
                end do
             end do
             wgt%pos(1)%pos(ix%ind)=+1 ! bottom right
             wgt%pos(2)%pos(iy%ind)=+1 ! top right
             wgt%pos(3)%pos(ix%ind)=-1 ! top left
             wgt%pos(4)%pos(iy%ind)=-1 ! bottom left (origo)
             ! write(*,'(X,A,6(F10.3,X))') 'Search done:',xs(1,1),xs(2,2),xf,ys(1,1),ys(2,2),yf
             if (bdeb) write(*,*)"XYSEARCH Done:",wgt%w
          else if (.not.changed) then ! not inside + no valid step
             if (bdeb) then
                write(*,'(X,A,6(F10.3,X))') 'Search fail:',xs(1,1),xs(2,2),xf,ys(1,1),ys(2,2),yf
             end if
             bdone=.true.
             biok=.false.
             return
          end if
       end if
    end do
    return
  end subroutine interpolate2D

  subroutine printWeight(wgt)
    implicit none
    type(weight) :: wgt
    integer ii
    CHARACTER*12 MYNAME
    DATA MYNAME /'printWeight'/
    do jj=1,wgt%nweight
       write(*,*) 'printWeight Weight:',jj,wgt%w(jj)
       do ii=1,wgt%pos(jj)%nrdim
          write(*,*) 'printWeight      Pos:',ii,wgt%pos(jj)%pos(ii)
       end do
    end do
  end subroutine printWeight

  subroutine printPos(pos)
    implicit none
    type(position) :: pos
    integer ii
    CHARACTER*12 MYNAME
    DATA MYNAME /'printPos'/
    if (pos%nrdim .gt.0) then
       do ii=1,pos%nrdim
          write(*,'(X,A," (",I3,")=",I8,"  (",I4,I4," )")') 'printPos',ii,pos%pos(ii),pos%sta(ii),pos%lim(ii)
       end do
    else
       write(*,*)'printPos: Position has no dimensions!'
    end if
    return
  end subroutine printPos


  character*6 function gettype(type)
    integer type
    if (type.eq.nf_char) then
       gettype="char  "
    elseif (type.eq.nf_int1) then
       gettype="int1  "
    elseif (type.eq.nf_int2) then
       gettype="int2  "
    elseif (type.eq.nf_int) then
       gettype="int   "
    elseif (type.eq.nf_real) then
       gettype="real  "
    elseif (type.eq.nf_double) then
       gettype="double"
    else
       gettype="any   "
    end if
    return
  end function gettype

  real function getDist(LATA,LONA,LATB,LONB)
    IMPLICIT NONE
    SAVE
    REAL   LONA,LATA,LONB,LATB
    REAL   CDIFF
    real sindeg, cosdeg,acosdeg
    external sindeg,cosdeg,acosdeg
    CHARACTER*8 MYNAME 
    DATA MYNAME /'getDist'/
    CDIFF=SINDEG(LATA)*SINDEG(LATB)+COSDEG(LATA)*COSDEG(LATB)*COSDEG(LONA-LONB)
    CDIFF=MAX(-1.0D0,MIN(1.0D0,CDIFF)) ! handle truncation errors
    getDist=ABS(ACOSDEG(CDIFF))
    RETURN
  END function getDist


  logical function getFootIndex(f,i,s,latc,lonc,diam,irc)
    implicit none
    type(inventory), pointer    :: f
    type(dimensionOrder), pointer        :: i
    type(dimensionOrder), pointer        :: s
    real latc
    real lonc
    real diam ! diameter in degrees
    integer irc
    integer dn(2),ii
    logical biok
    real latx,lonx,dist
    type(dimension), pointer :: d,e
    ! find increment distance in each dimension direction
    biok=.true.
    latc=ncf_valuePosition(f%latid,irc)
    if (irc.ne.0) then
       write(*,*) myname,'Error return from valuePos.',irc
       return
    end if
    lonc=ncf_valuePosition(f%lonid,irc)
    if (irc.ne.0) then
       write(*,*) myname,'Error return from valuePos.',irc
       return
    end if
    do ii=1,i%nrdim ! must be 2 (checked earlier)
       d=>getdim(i,ii)
       e=>getdim(s,ii)
       if (d%ind .ne. e%ind) then
          write(*,*)'System error:',d%ind,e%ind
          irc=845
          return
       end if
       e%sta=f%pos%pos(e%ind)
       if (biok) then
          biok=ncf_incrementDimension(f,d,biok,1,0,irc)
          if (irc.ne.0) then
             write(*,*) myname,'Error return from incrementDimension.',irc
             return
          end if
       end if
       if (biok) then
          latx=ncf_valuePosition(f%latid,irc)
          if (irc.ne.0) then
             write(*,*) myname,'Error return from valuePos.',irc
             return
          end if
          lonx=ncf_valuePosition(f%lonid,irc)
          if (irc.ne.0) then
             write(*,*) myname,'Error return from valuePos.',irc
             return
          end if
          biok=ncf_decrementDimension(f,d,biok,1,0,irc)
          if (irc.ne.0) then
             write(*,*) myname,'Error return from decrementPos.',irc
             return
          end if
          dist=2.0D0*getDist(latc,lonc,latx,lonx)
          dn(ii)=max(1,1+int(diam/max(dist,1.0D-10)))
       end if
    end do
    ! determine lower left corner
    if (biok) then
       do ii=1,i%nrdim ! must be 2 (checked earlier)
          d=>getdim(i,ii)
          biok=ncf_decrementDimension(f,d,biok,dn(ii),0,irc)
          if (irc.ne.0) then
             write(*,*) myname,'Error return from decrementPos.',irc
             return
          end if
          e=>getdim(s,ii)
          e%sta=e%sta-dn(ii)
          e%lim=e%sta+2*dn(ii)
          if (e%sta.lt.1.or.e%lim.gt.f%pos%lim(e%ind)) biok=.false.
       end do
    end if
    !    call printIndex(s)
    getFootIndex=biok
  end function getFootIndex

  logical function incrementFoot(f,i,latc,lonc,diam,irc)
    implicit none
    type(inventory), pointer    :: f
    type(dimensionOrder), pointer        :: i
    real latc
    real lonc
    real diam
    logical reset
    integer irc
    real latx,lonx,dist
    logical bdone
    CHARACTER*14 MYNAME
    DATA MYNAME /'incrementFoot'/
    bdone=.false.
    do while (.not. bdone)
       if (ncf_increment(f,i,irc)) then
          ! call printIndex(i)
          ! call printPos(f%pos)
          latx=ncf_valuePosition(f%latid,irc)
          if (irc.ne.0) then
             write(*,*) myname,'Error return from valuePos (latid).',irc
             return
          end if
          lonx=ncf_valuePosition(f%lonid,irc)
          if (irc.ne.0) then
             write(*,*) myname,'Error return from valuePos (lonid).',irc
             return
          end if
          dist=2.0D0*getDist(latc,lonc,latx,lonx)
          if (dist.lt.diam) then ! grid wihin footprint...
             bdone=.true.
          end if
          incrementFoot=.true.
       else !     no more grid points to check
          incrementFoot=.false.
          bdone=.true.
       end if
       if (irc.ne.0) then
          write(*,*) myname,'Error return from incrementPos.',irc
          return
       end if
    end do
  end function incrementFoot
  real function s1970(yy,mm,dd,hh,mi,sec)
    implicit none
    integer YY
    integer mm
    integer dd
    integer hh
    integer mi
    real sec
    !     returns "seconds since 1970-01-01 00:00:00 +00:00"
    real days
    !     yy=1970
    !     mm=01
    !     dd=01
    !     hh=00
    !     mi=00
    !     sec=0.0D0
    !     call jd2000(days,yy,mm,dd,hh,mi,sec)
    !     write(*,*) 'S1970 1970-reference in J2000:',days!  -10957.000000000000 
    call jd2000(days,yy,mm,dd,hh,mi,sec) ! get days since 2000/1/1 0:0
    days = days + 10957.0D0   ! convert to days since reference
    S1970=days*86400.0D0      ! convert to seconds
    return
  end function s1970
  real function j2000(sec)
    implicit none
    real sec
    j2000=sec/86400.0D0 - 10957.0D0  ! convert from seconds to days
    return
  end function j2000
  real function j1970(days)
    implicit none
    real days
    j1970=(10957.0D0+days)*86400.0D0 ! convert from days to seconds
    return
  end function j1970

  subroutine readfilter (crep,info,xml,nfilter,irc)
    implicit none
    type(report), pointer      :: crep
    type(XML_PARSE)            :: info
    type(xmltype)              :: xml
    type(filter), pointer      :: nfilter
    integer :: irc
    integer :: ii,cnt
    !
    type node ! filter definition
       type(node), pointer :: next => null()
       type(node), pointer :: prev => null()
       real :: lat
       real :: lon
    end type node
    integer :: len2
    integer, external :: length
    type(node), pointer :: first=>null()
    type(node), pointer :: last=>null()
    type(node), pointer :: cnode,nnode
    logical llat,llon
    real minlat,maxlat,minlon,maxlon
    CHARACTER*12 MYNAME
    DATA MYNAME /'readFilter'/
    ! read until xml%endtag is reached
    DEFINE: do while(.not. (trim(xml%tag).eq."define".and.xml%endtag))
       call xml_get( info, xml%tag, xml%starttag, xml%endtag, xml%attribs, &
            & xml%no_attribs, xml%data, xml%no_data )
       if ( .not. xml_ok(info) ) exit DEFINE
       if (bdeb) write(*,*)myname,'Found DEFINE xml%tag:',&
            & trim(xml%tag),xml%starttag,xml%endtag
       if (trim(xml%tag).eq."slice") then
          nfilter%mpar=100
          allocate(nfilter%lpar(0:nfilter%mpar),nfilter%npar(nfilter%mpar),&
               & nfilter%rpar(nfilter%mpar),stat=irc)
          if (irc.ne.0) then
             write(*,*) myname,'Unable to allocate filter-parameters.',irc
             return
          end if
          nfilter%lpar(:)=.false.
          nfilter%npar(:)=0
          nfilter%rpar(:)=0.0D0
          if (xml%starttag) then
             nfilter%type=flt_slice ! slice
             nfilter%lpar(0)=.true. ! need initialisation
             do ii=1,xml%no_attribs
                call replaceENV(xml%attribs(2,ii),irc)
                if (irc.ne.0) then
                   write(*,*)myname,'Error return from replaceEnv.',irc
                   return
                end if
                len2=length(xml%attribs(2,ii),700,10)    
                if (trim(xml%attribs(1,ii)).eq."volume") then
                   if (xml%attribs(2,ii)(1:len2).eq."frontside") then
                      nfilter%inside = .true. ! front
                   else if (xml%attribs(2,ii)(1:len2).eq."backside") then
                      nfilter%inside = .false. ! back
                   else
                      write(*,*)myname,'Unknown setting:',trim(xml%tag)//':'//&
                           & trim(xml%attribs(1,ii))
                   end if
                   !                       else if (trim(xml%attribs(1,ii)).eq."surface") then
                   !                          nfilter%var250=xml%attribs(2,ii)(1:len2)
                   !                          nfilter%lpar(100)=.true.
                else
                   write(*,*)myname,'Unknown attribute:',trim(xml%tag)//':'//&
                        & trim(xml%attribs(1,ii))
                   irc=803
                   return
                end if
             end do
          end if
          ! read until xml%endtag is reached
          SLICE: do while(.not. (trim(xml%tag).eq."slice".and.xml%endtag))
             call xml_get( info, xml%tag, xml%starttag, xml%endtag, xml%attribs, &
                  & xml%no_attribs, xml%data, xml%no_data )
             if ( .not. xml_ok(info) ) exit SLICE
             if (bdeb) write(*,*)myname,'Found DEFINE/SLICE xml%tag:',&
                  & trim(xml%tag),xml%starttag,xml%endtag
             if (trim(xml%tag).eq."origo") then
                do ii=1,xml%no_attribs
                   call replaceENV(xml%attribs(2,ii),irc)
                   if (irc.ne.0) then
                      write(*,*)myname,'Error return from replaceEnv.',irc
                      return
                   end if
                   len2=length(xml%attribs(2,ii),700,10)    
                   if (trim(xml%attribs(1,ii)).eq."lat") then
                      read(xml%attribs(2,ii)(1:len2),*,iostat=irc) nfilter%rpar(1)
                      if (irc.ne.0) then
                         write(*,*)myname,'Unable to read slice-ori-lat:',&
                              & xml%attribs(2,ii)(1:len2)
                         return
                      end if
                      nfilter%lpar(1)=.true.
                   elseif (trim(xml%attribs(1,ii)).eq."lon") then
                      read(xml%attribs(2,ii)(1:len2),*,iostat=irc) nfilter%rpar(2)
                      if (irc.ne.0) then
                         write(*,*)myname,'Unable to read slice-ori-lon:',xml%attribs(2,ii)(1:len2)
                         return
                      end if
                      nfilter%lpar(2)=.true.
                   elseif (trim(xml%attribs(1,ii)).eq."altitude") then
                      read(xml%attribs(2,ii)(1:len2),*,iostat=irc) nfilter%rpar(3)
                      if (irc.ne.0) then
                         write(*,*)myname,'Unable to read slice-ori-alt:',xml%attribs(2,ii)(1:len2)
                         return
                      end if
                      nfilter%lpar(3)=.true.
                   else
                      write(*,*)myname,'Unknown attribute:',trim(xml%tag)//':'//trim(xml%attribs(1,ii))
                      irc=804
                      return
                   end if
                end do
             else if (trim(xml%tag).eq."abscissa") then
                do ii=1,xml%no_attribs
                   call replaceENV(xml%attribs(2,ii),irc)
                   if (irc.ne.0) then
                      write(*,*)myname,'Error return from replaceEnv.',irc
                      return
                   end if
                   len2=length(xml%attribs(2,ii),700,10)    
                   if (trim(xml%attribs(1,ii)).eq."lat") then
                      read(xml%attribs(2,ii)(1:len2),*,iostat=irc) nfilter%rpar(5)
                      if (irc.ne.0) then
                         write(*,*)myname,'Unable to read slice-abs-lat:',xml%attribs(2,ii)(1:len2)
                         return
                      end if
                      nfilter%lpar(5)=.true.
                   elseif (trim(xml%attribs(1,ii)).eq."lon") then
                      read(xml%attribs(2,ii)(1:len2),*,iostat=irc) nfilter%rpar(6)
                      if (irc.ne.0) then
                         write(*,*)myname,'Unable to read slice-abs-lon:',xml%attribs(2,ii)(1:len2)
                         return
                      end if
                      nfilter%lpar(6)=.true.
                   elseif (trim(xml%attribs(1,ii)).eq."altitude") then
                      read(xml%attribs(2,ii)(1:len2),*,iostat=irc) nfilter%rpar(7)
                      if (irc.ne.0) then
                         write(*,*)myname,'Unable to read slice-abs-alt:',xml%attribs(2,ii)(1:len2)
                         return
                      end if
                      nfilter%lpar(7)=.true.
                   else
                      write(*,*)myname,'Unknown attribute:',trim(xml%tag)//':'//trim(xml%attribs(1,ii))
                      irc=805
                      return
                   end if
                end do
             else if (trim(xml%tag).eq."ordinate") then
                do ii=1,xml%no_attribs
                   call replaceENV(xml%attribs(2,ii),irc)
                   if (irc.ne.0) then
                      write(*,*)myname,'Error return from replaceEnv.',irc
                      return
                   end if
                   len2=length(xml%attribs(2,ii),700,10)    
                   if (trim(xml%attribs(1,ii)).eq."lat") then
                      read(xml%attribs(2,ii)(1:len2),*,iostat=irc) nfilter%rpar(11)
                      if (irc.ne.0) then
                         write(*,*)myname,'Unable to read slice-ord-lat:',xml%attribs(2,ii)(1:len2)
                         return
                      end if
                      nfilter%lpar(10)=.true.
                   elseif (trim(xml%attribs(1,ii)).eq."lon") then
                      read(xml%attribs(2,ii)(1:len2),*,iostat=irc) nfilter%rpar(12)
                      if (irc.ne.0) then
                         write(*,*)myname,'Unable to read slice-ord-lon:',xml%attribs(2,ii)(1:len2)
                         return
                      end if
                      nfilter%lpar(11)=.true.
                   elseif (trim(xml%attribs(1,ii)).eq."altitude") then
                      read(xml%attribs(2,ii)(1:len2),*,iostat=irc) nfilter%rpar(13)
                      if (irc.ne.0) then
                         write(*,*)myname,'Unable to read slice-ord-alt:',&
                              & xml%attribs(2,ii)(1:len2)
                         return
                      end if
                      nfilter%lpar(12)=.true.
                   else
                      write(*,*)myname,'Unknown attribute:',trim(xml%tag)//':'//&
                           & trim(xml%attribs(1,ii))
                      irc=806
                      return
                   end if
                end do
             else if (trim(xml%tag).eq."normal") then
                do ii=1,xml%no_attribs
                   call replaceENV(xml%attribs(2,ii),irc)
                   if (irc.ne.0) then
                      write(*,*)myname,'Error return from replaceEnv.',irc
                      return
                   end if
                   len2=length(xml%attribs(2,ii),700,10)    
                   if (trim(xml%attribs(1,ii)).eq."lat") then
                      read(xml%attribs(2,ii)(1:len2),*,iostat=irc) nfilter%rpar(15)
                      if (irc.ne.0) then
                         write(*,*)myname,'Unable to read slice-nor-lat:',&
                              & xml%attribs(2,ii)(1:len2)
                         return
                      end if
                      nfilter%lpar(15)=.true.
                   elseif (trim(xml%attribs(1,ii)).eq."lon") then
                      read(xml%attribs(2,ii)(1:len2),*,iostat=irc) nfilter%rpar(16)
                      if (irc.ne.0) then
                         write(*,*)myname,'Unable to read slice-nor-lon:',&
                              & xml%attribs(2,ii)(1:len2)
                         return
                      end if
                      nfilter%lpar(16)=.true.
                   elseif (trim(xml%attribs(1,ii)).eq."altitude") then
                      read(xml%attribs(2,ii)(1:len2),*,iostat=irc) nfilter%rpar(17)
                      if (irc.ne.0) then
                         write(*,*)myname,'Unable to read slice-nor-alt:',&
                              & xml%attribs(2,ii)(1:len2)
                         return
                      end if
                      nfilter%lpar(17)=.true.
                   else
                      write(*,*)myname,'Unknown attribute:',trim(xml%tag)//':'//&
                           & trim(xml%attribs(1,ii))
                      irc=807
                      return
                   end if
                end do
             else if (trim(xml%tag).ne."slice") then
                write(*,*)myname,'Unknown xml%tag C:',trim(xml%tag)
                irc=931
                return
             end if
          end do SLICE
       else if (trim(xml%tag).eq."cylinder") then
          nfilter%mpar=100
          allocate(nfilter%lpar(0:nfilter%mpar),nfilter%npar(nfilter%mpar),nfilter%rpar(nfilter%mpar),stat=irc)
          if (irc.ne.0) then
             write(*,*) myname,'Unable to allocate filter-parameters.',irc
             return
          end if
          nfilter%lpar(:)=.false.
          nfilter%npar(:)=0
          nfilter%rpar(:)=0.0D0
          if (xml%starttag) then
             nfilter%type=flt_cylinder ! cylinder
             nfilter%lpar(0)=.true. ! need initialisation
             do ii=1,xml%no_attribs
                call replaceENV(xml%attribs(2,ii),irc)
                if (irc.ne.0) then
                   write(*,*)myname,'Error return from replaceEnv.',irc
                   return
                end if
                len2=length(xml%attribs(2,ii),700,10)    
                if (trim(xml%attribs(1,ii)).eq."volume") then
                   if (xml%attribs(2,ii)(1:len2).eq."inside") then
                      nfilter%inside = .true. ! inside
                   else if (xml%attribs(2,ii)(1:len2).eq."outside") then
                      nfilter%inside = .false. ! outside
                   else
                      write(*,*)myname,'Unknown setting:',trim(xml%tag)//':'//&
                           & trim(xml%attribs(1,ii))
                   end if
                   !                       else if (trim(xml%attribs(1,ii)).eq."surface") then
                   !                          nfilter%var250=xml%attribs(2,ii)(1:len2)
                   !                          nfilter%lpar(100)=.true.
                else
                   write(*,*)myname,'Unknown attribute:',trim(xml%tag)//':'//&
                        & trim(xml%attribs(1,ii))
                   irc=808
                   return
                end if
             end do
          end if
          ! read until xml%endtag is reached
          CYLINDER: do while(.not. (trim(xml%tag).eq."cylinder".and.xml%endtag))
             call xml_get( info, xml%tag, xml%starttag, xml%endtag, xml%attribs, xml%no_attribs, xml%data, xml%no_data )
             if ( .not. xml_ok(info) ) exit CYLINDER
             if (bdeb) write(*,*)myname,'Found DEFINE/CYLINDER xml%tag:',&
                  & trim(xml%tag),xml%starttag,xml%endtag
             if (trim(xml%tag).eq."center") then
                do ii=1,xml%no_attribs
                   call replaceENV(xml%attribs(2,ii),irc)
                   if (irc.ne.0) then
                      write(*,*)myname,'Error return from replaceEnv.',irc
                      return
                   end if
                   len2=length(xml%attribs(2,ii),700,10)    
                   if (trim(xml%attribs(1,ii)).eq."lat") then
                      read(xml%attribs(2,ii)(1:len2),*,iostat=irc) nfilter%rpar(1)
                      if (irc.ne.0) then
                         write(*,*)myname,'Unable to read slice-ori-lat:',&
                              & xml%attribs(2,ii)(1:len2)
                         return
                      end if
                      nfilter%lpar(1)=.true.
                   elseif (trim(xml%attribs(1,ii)).eq."lon") then
                      read(xml%attribs(2,ii)(1:len2),*,iostat=irc) nfilter%rpar(2)
                      if (irc.ne.0) then
                         write(*,*)myname,'Unable to read slice-ori-lon:',&
                              & xml%attribs(2,ii)(1:len2)
                         return
                      end if
                      nfilter%lpar(2)=.true.
                   elseif (trim(xml%attribs(1,ii)).eq."altitude") then
                      read(xml%attribs(2,ii)(1:len2),*,iostat=irc) nfilter%rpar(3)
                      if (irc.ne.0) then
                         write(*,*)myname,'Unable to read slice-ori-alt:',&
                              & xml%attribs(2,ii)(1:len2)
                         return
                      end if
                      nfilter%lpar(3)=.true.
                   elseif (trim(xml%attribs(1,ii)).eq."width") then
                      read(xml%attribs(2,ii)(1:len2),*,iostat=irc) nfilter%rpar(4)
                      if (irc.ne.0) then
                         write(*,*)myname,'Unable to read slice-ori-alt:',&
                              & xml%attribs(2,ii)(1:len2)
                         return
                      end if
                      nfilter%lpar(4)=.true.
                   elseif (trim(xml%attribs(1,ii)).eq."height") then
                      read(xml%attribs(2,ii)(1:len2),*,iostat=irc) nfilter%rpar(5)
                      if (irc.ne.0) then
                         write(*,*)myname,'Unable to read slice-ori-alt:',&
                              & xml%attribs(2,ii)(1:len2)
                         return
                      end if
                      nfilter%lpar(5)=.true.
                   else
                      write(*,*)myname,'Unknown attribute:',trim(xml%tag)//':'//&
                           & trim(xml%attribs(1,ii))
                      irc=809
                      return
                   end if
                end do
             else if (trim(xml%tag).ne."cylinder") then
                write(*,*)myname,'Unknown xml%tag D:',trim(xml%tag)
                irc=932
                return
             end if
          end do CYLINDER
       else if (trim(xml%tag).eq."polygon") then
          nfilter%mpar=0
          allocate(nfilter%lpar(0:1),nfilter%npar(1),stat=irc)
          if (irc.ne.0) then
             write(*,*) myname,'Unable to allocate filter-parameters.',irc
             return
          end if
          if (xml%starttag) then
             nfilter%type=flt_polygon ! polygon
             nfilter%lpar(0)=.true. ! need initialisation
             do ii=1,xml%no_attribs
                call replaceENV(xml%attribs(2,ii),irc)
                if (irc.ne.0) then
                   write(*,*)myname,'Error return from replaceEnv.',irc
                   return
                end if
                len2=length(xml%attribs(2,ii),700,10)    
                if (trim(xml%attribs(1,ii)).eq."volume") then
                   if (xml%attribs(2,ii)(1:len2).eq."inside") then
                      nfilter%inside = .true. ! inside
                   else if (xml%attribs(2,ii)(1:len2).eq."outside") then
                      nfilter%inside = .false. ! outside
                   else
                      write(*,*)myname,'Unknown setting:',trim(xml%tag)//':'//trim(xml%attribs(1,ii))
                   end if
                   !                       else if (trim(xml%attribs(1,ii)).eq."surface") then
                   !                          nfilter%var250=xml%attribs(2,ii)(1:len2)
                   !                          nfilter%lpar(100)=.true.
                else if (trim(xml%attribs(1,ii)).eq."simplify") then
                   if (xml%attribs(2,ii)(1:len2).eq."never") then
                      nfilter%simplify = .false. ! dont simplify
                   end if
                else if (trim(xml%attribs(1,ii)).eq."tolerance") then
                   read(xml%attribs(2,ii)(1:len2),*,iostat=irc) nfilter%eps
                   if (irc.ne.0) then
                      write(*,*)myname,'Error reading attribute:',xml%attribs(2,ii)
                      return
                   end if
                   if (nfilter%eps <=0.0D0) then
                      nfilter%simplify=.false.
                   end if
                else
                   write(*,*)myname,'Unknown attribute:',trim(xml%tag)//':'//&
                        & trim(xml%attribs(1,ii))
                   irc=810
                   return
                end if
             end do
             allocate(first, last)
             first%next => last
             last%prev => first
          end if
          ! read until xml%endtag is reached
          llat=.false.
          llon=.false.
          cnt=0
          POLYGON: do while(.not. (trim(xml%tag).eq."polygon".and.xml%endtag))
             call xml_get( info, xml%tag, xml%starttag, xml%endtag, xml%attribs, &
                  & xml%no_attribs, xml%data, xml%no_data )
             if ( .not. xml_ok(info) ) exit POLYGON
             cnt=cnt+1
             if (bdeb.and.cnt.lt.3) write(*,*)myname,'Found DEFINE/POLYGON xml%tag:',&
                  & trim(xml%tag),xml%starttag,xml%endtag
             if (bdeb.and.cnt.eq.3) write(*,*)myname,'Found DEFINE/POLYGON xml%tag...'
             if (trim(xml%tag).eq."node") then
                do ii=1,xml%no_attribs
                   call replaceENV(xml%attribs(2,ii),irc)
                   if (irc.ne.0) then
                      write(*,*)myname,'Error return from replaceEnv.',irc
                      return
                   end if
                   len2=length(xml%attribs(2,ii),700,10)    
                   if (trim(xml%attribs(1,ii)).eq."lat") then
                      read(xml%attribs(2,ii)(1:len2),*,iostat=irc) lat
                      if (irc.ne.0) then
                         write(*,*)myname,'Error reading attribute:',xml%attribs(2,ii)
                         return
                      end if
                      if (.not.llat) then
                         llat=.true.
                         minlat=lat
                         maxlat=lat
                      else
                         minlat=min(minlat,lat)
                         maxlat=max(maxlat,lat)
                      end if
                      if (irc.ne.0) then
                         write(*,*)myname,'Unable to read slice-ori-lat:',&
                              & xml%attribs(2,ii)(1:len2)
                         return
                      end if
                   elseif (trim(xml%attribs(1,ii)).eq."lon") then
                      read(xml%attribs(2,ii)(1:len2),*,iostat=irc) lon
                      if (irc.ne.0) then
                         write(*,*)myname,'Error reading attribute:',xml%attribs(2,ii)
                         return
                      end if
                      if (.not.llon) then
                         llon=.true.
                         minlon=lon
                         maxlon=lon
                      else
                         minlon=min(minlon,lon)
                         maxlon=max(maxlon,lon)
                      end if
                      if (irc.ne.0) then
                         write(*,*)myname,'Unable to read slice-ori-lon:',&
                              & xml%attribs(2,ii)(1:len2)
                         return
                      end if
                   else
                      write(*,*)myname,'Unknown attribute:',trim(xml%tag)//':'//&
                           & trim(xml%attribs(1,ii))
                      irc=812
                      return
                   end if
                end do
                if (llat.and.llon) then
                   allocate(cnode,stat=irc)
                   if (irc.ne.0) then
                      write(*,*) myname,'Error return from allocate (cnode).',irc
                      return
                   end if
                   cnode%prev=>last%prev
                   cnode%next=>last
                   cnode%prev%next => cnode
                   cnode%next%prev => cnode
                   cnode%lat=lat
                   cnode%lon=lon
                   nfilter%mpar=nfilter%mpar+1
                else
                   write(*,*)'Ignoring mask-node missing LAT/LON.'
                end if
             else if (trim(xml%tag).ne."polygon") then
                write(*,*)myname,'Unknown xml%tag E:',trim(xml%tag)
                irc=933
                return
             end if
          end do POLYGON
          if (nfilter%mpar .lt. 3) then
             write(*,*) myname,'Too few nodes in polygon.',nfilter%mpar
             irc=458
             return
          end if
          allocate(nfilter%rpar(nfilter%mpar*2+4),stat=irc)
          if (irc.ne.0) then
             write(*,*) myname,'Unable to allocate filter-parameters.',irc
             return
          end if
          nfilter%rpar(:)=0.0D0
          nfilter%lpar(:)=.false.
          nfilter%npar(:)=0
          ii=0
          cnode => first%next
          do while (.not.associated(cnode, target=last))
             ii=ii+1
             nfilter%rpar(ii)=cnode%lat
             nfilter%rpar(ii+nfilter%mpar)=cnode%lon
             cnode => cnode%next
          end do
          !write(*,*)myname,'LATLON:',minlat,maxlat,minlon,maxlon
          nfilter%rpar(nfilter%mpar*2+1)=minlat
          nfilter%rpar(nfilter%mpar*2+2)=maxlat
          nfilter%rpar(nfilter%mpar*2+3)=minlon
          nfilter%rpar(nfilter%mpar*2+4)=maxlon
          ! simplify filter
          ii=nfilter%mpar
          if (nfilter%simplify) then
             call simplify(nfilter%mpar,nfilter%rpar,nfilter%eps)
             if (nfilter%mpar.gt.ii) then
                write(*,*)myname,'Corrupt simplification.',nfilter%mpar,ii
                irc=999
                return
             end if
          end if
          ! the next bit is done automatically by simplify...
          !nfilter%rpar(nfilter%mpar*2+1)=nfilter%rpar(ii*2+1)
          !nfilter%rpar(nfilter%mpar*2+2)=nfilter%rpar(ii*2+2)
          !nfilter%rpar(nfilter%mpar*2+3)=nfilter%rpar(ii*2+3)
          !nfilter%rpar(nfilter%mpar*2+4)=nfilter%rpar(ii*2+4)
          cnode => first%next
          do while (.not.associated(cnode, target=last))
             nnode=>cnode%next
             if (associated(cnode)) deallocate(cnode)
             cnode => nnode
          end do
          !if (associated(first)) deallocate(first)
          !if (associated(last)) deallocate(last)
          ! dump polygon to json-file
          if (crep%lpoly) then
             call chop0(crep%poly350,350)
             call writePolygon(crep%poly350,nfilter%mpar,nfilter%rpar,nfilter%eps,irc)
             if (irc.ne.0) then
                write(*,*) myname,'Error return from writePoly.',irc
                return
             end if
          end if
       else if (trim(xml%tag).eq."duct") then
          nfilter%mpar=100
          allocate(nfilter%lpar(0:nfilter%mpar),nfilter%npar(nfilter%mpar),&
               & nfilter%rpar(nfilter%mpar),stat=irc)
          if (irc.ne.0) then
             write(*,*) myname,'Unable to allocate filter-parameters.',irc
             return
          end if
          nfilter%lpar(:)=.false.
          nfilter%npar(:)=0
          nfilter%rpar(:)=0.0D0
          if (xml%starttag) then
             nfilter%type=flt_duct ! duct
             nfilter%lpar(0)=.true. ! need initialisation
             do ii=1,xml%no_attribs
                call replaceENV(xml%attribs(2,ii),irc)
                if (irc.ne.0) then
                   write(*,*)myname,'Error return from replaceEnv.',irc
                   return
                end if
                len2=length(xml%attribs(2,ii),700,10)    
                if (trim(xml%attribs(1,ii)).eq."volume") then
                   if (xml%attribs(2,ii)(1:len2).eq."inside") then
                      nfilter%inside = .true. ! inside
                   else if (xml%attribs(2,ii)(1:len2).eq."outside") then
                      nfilter%inside = .false. ! outside
                   else
                      write(*,*)myname,'Unknown setting:',trim(xml%tag)//':'//&
                           & trim(xml%attribs(1,ii))
                   end if
                   !                       else if (trim(xml%attribs(1,ii)).eq."surface") then
                   !                          nfilter%var250=xml%attribs(2,ii)(1:len2)
                   !                          nfilter%lpar(100)=.true.
                else
                   write(*,*)myname,'Unknown attribute:',trim(xml%tag)//':'//&
                        & trim(xml%attribs(1,ii))
                   irc=810
                   return
                end if
             end do
          end if
          ! read until xml%endtag is reached
          DUCT: do while(.not. (trim(xml%tag).eq."duct".and.xml%endtag))
             call xml_get( info, xml%tag, xml%starttag, xml%endtag, xml%attribs, &
                  & xml%no_attribs, xml%data, xml%no_data )
             if ( .not. xml_ok(info) ) exit DUCT
             if (bdeb) write(*,*)myname,'Found DEFINE/DUCT xml%tag:',trim(xml%tag),&
                  & xml%starttag,xml%endtag
             if (trim(xml%tag).eq."start") then
                do ii=1,xml%no_attribs
                   call replaceENV(xml%attribs(2,ii),irc)
                   if (irc.ne.0) then
                      write(*,*)myname,'Error return from replaceEnv.',irc
                      return
                   end if
                   len2=length(xml%attribs(2,ii),700,10)    
                   if (trim(xml%attribs(1,ii)).eq."lat") then
                      read(xml%attribs(2,ii)(1:len2),*,iostat=irc) nfilter%rpar(1)
                      if (irc.ne.0) then
                         write(*,*)myname,'Unable to read slice-ori-lat:',&
                              & xml%attribs(2,ii)(1:len2)
                         return
                      end if
                      nfilter%lpar(1)=.true.
                   elseif (trim(xml%attribs(1,ii)).eq."lon") then
                      read(xml%attribs(2,ii)(1:len2),*,iostat=irc) nfilter%rpar(2)
                      if (irc.ne.0) then
                         write(*,*)myname,'Unable to read slice-ori-lon:',&
                              & xml%attribs(2,ii)(1:len2)
                         return
                      end if
                      nfilter%lpar(2)=.true.
                   elseif (trim(xml%attribs(1,ii)).eq."altitude") then
                      read(xml%attribs(2,ii)(1:len2),*,iostat=irc) nfilter%rpar(3)
                      if (irc.ne.0) then
                         write(*,*)myname,'Unable to read slice-ori-alt:',&
                              & xml%attribs(2,ii)(1:len2)
                         return
                      end if
                      nfilter%lpar(3)=.true.
                   elseif (trim(xml%attribs(1,ii)).eq."width") then
                      read(xml%attribs(2,ii)(1:len2),*,iostat=irc) nfilter%rpar(4)
                      if (irc.ne.0) then
                         write(*,*)myname,'Unable to read slice-ori-alt:',&
                              & xml%attribs(2,ii)(1:len2)
                         return
                      end if
                      nfilter%lpar(4)=.true.
                   elseif (trim(xml%attribs(1,ii)).eq."height") then
                      read(xml%attribs(2,ii)(1:len2),*,iostat=irc) nfilter%rpar(5)
                      if (irc.ne.0) then
                         write(*,*)myname,'Unable to read slice-ori-alt:',&
                              & xml%attribs(2,ii)(1:len2)
                         return
                      end if
                      nfilter%lpar(5)=.true.
                   else
                      write(*,*)myname,'Unknown attribute:',trim(xml%tag)//':'//&
                           & trim(xml%attribs(1,ii))
                      irc=811
                      return
                   end if
                end do
             else if (trim(xml%tag).eq."stop") then
                nfilter%lpar(2)=.true.
                do ii=1,xml%no_attribs
                   call replaceENV(xml%attribs(2,ii),irc)
                   if (irc.ne.0) then
                      write(*,*)myname,'Error return from replaceEnv.',irc
                      return
                   end if
                   len2=length(xml%attribs(2,ii),700,10)    
                   if (trim(xml%attribs(1,ii)).eq."lat") then
                      read(xml%attribs(2,ii)(1:len2),*,iostat=irc) nfilter%rpar(11)
                      if (irc.ne.0) then
                         write(*,*)myname,'Unable to read slice-ori-lat:',&
                              & xml%attribs(2,ii)(1:len2)
                         return
                      end if
                      nfilter%lpar(11)=.true.
                   elseif (trim(xml%attribs(1,ii)).eq."lon") then
                      read(xml%attribs(2,ii)(1:len2),*,iostat=irc) nfilter%rpar(12)
                      if (irc.ne.0) then
                         write(*,*)myname,'Unable to read slice-ori-lon:',&
                              & xml%attribs(2,ii)(1:len2)
                         return
                      end if
                      nfilter%lpar(12)=.true.
                   elseif (trim(xml%attribs(1,ii)).eq."altitude") then
                      read(xml%attribs(2,ii)(1:len2),*,iostat=irc) nfilter%rpar(13)
                      if (irc.ne.0) then
                         write(*,*)myname,'Unable to read slice-ori-alt:',&
                              & xml%attribs(2,ii)(1:len2)
                         return
                      end if
                      nfilter%lpar(13)=.true.
                   elseif (trim(xml%attribs(1,ii)).eq."width") then
                      read(xml%attribs(2,ii)(1:len2),*,iostat=irc) nfilter%rpar(14)
                      if (irc.ne.0) then
                         write(*,*)myname,'Unable to read slice-ori-alt:',&
                              & xml%attribs(2,ii)(1:len2)
                         return
                      end if
                      nfilter%lpar(14)=.true.
                   elseif (trim(xml%attribs(1,ii)).eq."height") then
                      read(xml%attribs(2,ii)(1:len2),*,iostat=irc) nfilter%rpar(15)
                      if (irc.ne.0) then
                         write(*,*)myname,'Unable to read slice-ori-alt:',&
                              & xml%attribs(2,ii)(1:len2)
                         return
                      end if
                      nfilter%lpar(15)=.true.
                   else
                      write(*,*)myname,'Unknown attribute:',trim(xml%tag)//':'//&
                           & trim(xml%attribs(1,ii))
                      irc=812
                      return
                   end if
                end do
             else if (trim(xml%tag).ne."duct") then
                write(*,*)myname,'Unknown xml%tag G:',trim(xml%tag)
                irc=933
                return
             end if
          end do DUCT
       else if (trim(xml%tag).eq."value") then
          nfilter%mpar=100
          allocate(nfilter%lpar(0:nfilter%mpar),nfilter%npar(nfilter%mpar),&
               & nfilter%rpar(nfilter%mpar),stat=irc)
          if (irc.ne.0) then
             write(*,*) myname,'Unable to allocate filter-parameters.',irc
             return
          end if
          nfilter%lpar(:)=.false.
          nfilter%npar(:)=0
          nfilter%rpar(:)=0.0D0
          if (xml%starttag) then
             nfilter%type=flt_value ! value
             nfilter%lpar(0)=.true. ! need initialisation
             do ii=1,xml%no_attribs
                call replaceENV(xml%attribs(2,ii),irc)
                if (irc.ne.0) then
                   write(*,*)myname,'Error return from replaceEnv.',irc
                   return
                end if
                len2=length(xml%attribs(2,ii),700,10)    
                if (trim(xml%attribs(1,ii)).eq."parameter") then
                   nfilter%var250=xml%attribs(2,ii)(1:len2)
                   nfilter%ipar=.true.
                else if (trim(xml%attribs(1,ii)).eq."min") then
                   read(xml%attribs(2,ii)(1:len2),*,iostat=irc) nfilter%rpar(1)
                   if (irc.ne.0) then
                      write(*,*)myname,'Unable to read slice-ori-alt:',&
                           & xml%attribs(2,ii)(1:len2)
                      return
                   end if
                   nfilter%lpar(1)=.true.
                else if (trim(xml%attribs(1,ii)).eq."max") then
                   read(xml%attribs(2,ii)(1:len2),*,iostat=irc) nfilter%rpar(2)
                   if (irc.ne.0) then
                      write(*,*)myname,'Unable to read slice-ori-alt:',&
                           & xml%attribs(2,ii)(1:len2)
                      return
                   end if
                   nfilter%lpar(2)=.true.
                else
                   write(*,*)myname,'Unknown attribute:',trim(xml%tag)//':'//&
                        & trim(xml%attribs(1,ii))
                   irc=813
                   return
                end if
             end do
          end if
       else if (trim(xml%tag).eq."string") then
          nfilter%mpar=100
          allocate(nfilter%lpar(0:nfilter%mpar),nfilter%npar(nfilter%mpar),&
               & nfilter%rpar(nfilter%mpar),stat=irc)
          if (irc.ne.0) then
             write(*,*) myname,'Unable to allocate filter-parameters.',irc
             return
          end if
          nfilter%lpar(:)=.false.
          nfilter%npar(:)=0
          nfilter%rpar(:)=0.0D0
          if (xml%starttag) then
             nfilter%type=flt_string ! string
             nfilter%lpar(0)=.true. ! need initialisation
             do ii=1,xml%no_attribs
                call replaceENV(xml%attribs(2,ii),irc)
                if (irc.ne.0) then
                   write(*,*)myname,'Error return from replaceEnv.',irc
                   return
                end if
                len2=length(xml%attribs(2,ii),700,10)    
                if (trim(xml%attribs(1,ii)).eq."parameter") then
                   nfilter%var250=xml%attribs(2,ii)(1:len2)
                   nfilter%ipar=.true.
                else if (trim(xml%attribs(1,ii)).eq."target") then
                   nfilter%spar250=xml%attribs(2,ii)
                   call chop0(nfilter%spar250,250)
                   nfilter%lens=length(nfilter%spar250,250,3)
                   nfilter%lpar(1)=.true.
                else if (trim(xml%attribs(1,ii)).eq."dimension") then
                   nfilter%sdim80=xml%attribs(2,ii)(1:len2)
                   nfilter%lpar(2)=.true.
                else
                   write(*,*)myname,'Unknown attribute:',trim(xml%tag)//':'//&
                        & trim(xml%attribs(1,ii))
                   irc=813
                   return
                end if
             end do
          end if
       else if (trim(xml%tag).eq."dimension") then
          nfilter%mpar=100
          allocate(nfilter%lpar(0:nfilter%mpar),nfilter%npar(0:nfilter%mpar),&
               & nfilter%rpar(nfilter%mpar),stat=irc)
          if (irc.ne.0) then
             write(*,*) myname,'Unable to allocate filter-parameters.',irc,&
                  & nfilter%mpar
             return
          end if
          nfilter%lpar(:)=.false.
          nfilter%npar(:)=0
          nfilter%rpar(:)=0.0D0
          if (xml%starttag) then
             nfilter%type=flt_dimension ! dimension
             nfilter%lpar(0)=.true. ! need initialisation
             do ii=1,xml%no_attribs
                call replaceENV(xml%attribs(2,ii),irc)
                if (irc.ne.0) then
                   write(*,*)myname,'Error return from replaceEnv.',irc
                   return
                end if
                len2=length(xml%attribs(2,ii),700,10)    
                if (trim(xml%attribs(1,ii)).eq."parameter") then
                   nfilter%var250=xml%attribs(2,ii)(1:len2)
                   nfilter%ipar=.true.
                else if (trim(xml%attribs(1,ii)).eq."name") then
                   nfilter%sdim80=xml%attribs(2,ii)(1:len2)
                   nfilter%lpar(4)=.true.
                else if (trim(xml%attribs(1,ii)).eq."min") then
                   read(xml%attribs(2,ii)(1:len2),*,iostat=irc) nfilter%npar(1)
                   if (irc.ne.0) then
                      write(*,*)myname,'Unable to read dim-min:',xml%attribs(2,ii)(1:len2)
                      return
                   end if
                   nfilter%lpar(1)=.true.
                else if (trim(xml%attribs(1,ii)).eq."max") then
                   read(xml%attribs(2,ii)(1:len2),*,iostat=irc) nfilter%npar(2)
                   if (irc.ne.0) then
                      write(*,*)myname,'Unable to read dim-max:',xml%attribs(2,ii)(1:len2)
                      return
                   end if
                   nfilter%lpar(2)=.true.
                else
                   write(*,*)myname,'Unknown attribute:',trim(xml%tag)//':'//&
                        & trim(xml%attribs(1,ii))
                   irc=813
                   return
                end if
             end do
          end if
       else if (trim(xml%tag).ne."define") then
          write(*,*)myname,'Unknown xml%tag H:',trim(xml%tag)
          irc=934
          return
       end if
    end do DEFINE
    if (associated(first)) deallocate(first)
    if (associated(last)) deallocate(last)
    return
  end subroutine READFILTER

  subroutine readDataFile(file,bok,irc)
    implicit none
    type(filetype) :: file
    logical :: bok
    integer :: irc
    !
    type(Dimension), pointer :: sd => null()
    type(variable), pointer :: v
    type(report), pointer :: crep
    type(parameter), pointer :: cpar,bpar
    integer :: lenc
    CHARACTER*14 MYNAME 
    DATA MYNAME /'readdatafile'/
    !
    if (bok) then
       file%rok(1)=file%rok(1)+1
    else
       file%rrm(1)=file%rrm(1)+1 ! unable to open file
    end if
    if (bok) then
       call ncf_readInventory(file%ref,bok,irc)
       if (irc.ne.0) then
          write(*,*)myname,'Error return from readInventory.',irc
          return
       end if
       if (bok) then
          file%rok(2)=file%rok(2)+1
       else
          file%rrm(2)=file%rrm(2)+1 ! unable to read inventory
       end if
    end if
    !
    ! check that latitude, longitude and altitude are present...
    !
    if (bok) then
       write(*,*)myname,'Checking inventory.'
       call ncf_checkCoordinates(file%ref,bok,irc)
       if (irc.ne.0) then
          write(*,*)myname,'Error return from checkContents.',irc
          return
       end if
       if (bok) then
          file%rok(3)=file%rok(3)+1
       else
          file%rrm(3)=file%rrm(3)+1 ! contents error
       end if
    end if
    !
    ! make indexes
    !
    if (bok) then
       call ncf_clearDimOrder(file%refLatDO)
       call ncf_clearDimOrder(file%refLonDO)
       call ncf_clearDimOrder(file%refAltDO)
       call ncf_clearDimOrder(file%refTimDO)
       call ncf_clearDimOrder(file%refAllDO)
       call ncf_clearDimOrder(file%refStrDO)
       call ncf_clearDimOrder(file%refDimDO)
       call ncf_clearDimOrder(file%refIterDO)
       file%refLatDO=>ncf_makeDimOrder(file%ref%latid,irc)
       if (irc.ne.0) then
          write(*,*)myname,'Error return from makeDimOrder (lat).',irc
          return
       end if
       file%refLonDO=>ncf_makeDimOrder(file%ref%lonid,irc)
       if (irc.ne.0) then
          write(*,*)myname,'Error return from makeDimOrder (lon).',irc
          return
       end if
       file%refAltDO=>ncf_makeDimOrder(file%ref%altid,irc)
       if (irc.ne.0) then
          write(*,*)myname,'Missing: altitude (ignoring).'
          irc=0
       end if
       file%refTimDO=>ncf_makeDimOrder(file%ref%timid,irc)
       if (irc.ne.0) then
          write(*,*)myname,'Error return from makeDimOrder (time).',irc
          return
       end if
       file%refStrDo=>ncf_newDimOrder(file%ref,irc)
       if (irc.ne.0) then
          write(*,*)myname,'Error return from newDimOrder (str).',irc
          return
       end if
       file%refDimDo=>ncf_newDimOrder(file%ref,irc)
       if (irc.ne.0) then
          write(*,*)myname,'Error return from newDimOrder (dim).',irc
          return
       end if
       !     file%refAllDO=>getAllIndex(file%ref,irc)
       ! remove any lat/lon dimensions from altitude
       call ncf_removeDimOrder(file%refAltDO,file%refLatDO)
       call ncf_removeDimOrder(file%refAltDO,file%refLonDO)
       !
       ! make index of inner dimensions (lat/lon dimensions)
       !
       file%refLatLonAltDO => ncf_copyDimOrder(file%refLatDO,irc)
       if (irc.ne.0) then
          write(*,*) myname,'Error return from copyDimOrder.',irc
          return
       end if
       call ncf_addDimOrder(file%refLatLonAltDO,file%refLonDO,irc)
       if (irc.ne.0) then
          write(*,*) myname,'Error return from addDimOrder.',irc
          return
       end if
       call ncf_addDimOrder(file%refLatLonAltDO,file%refAltDO,irc)
       if (irc.ne.0) then
          write(*,*) myname,'Error return from addDimOrder.',irc
          return
       end if
    end if
    !
    ! read non-parameter fields into memory
    !
    if (bok) then
       ! read reference latitude field into memory
       v=>file%ref%latid
       bbok=.true.
       if (v%lend.le.0) then ! not in memory
          write(*,*)myname,'Reading variable:',v%var250(1:v%lenv)
          call ncf_readRealData(v,bbok,irc)
          if (irc.ne.0) then
             write(*,*)myname,'Error return from latid-readData.',irc
             return
          end if
       end if

       ! read reference longitude field into memory
       v=>file%ref%lonid
       if (v%lend.le.0) then ! not in memory
          write(*,*)myname,'Reading variable:',v%var250(1:v%lenv)
          call ncf_readRealData(v,bbok,irc)
          if (irc.ne.0) then
             write(*,*)myname,'Error return from lonid-readData.',irc
             return
          end if
       end if
       if (associated(file%ref%altid)) then
          ! read reference altitude field into memory
          v=>file%ref%altid
          if (v%lend.le.0) then ! not in memory
             write(*,*)myname,'Reading variable:',v%var250(1:v%lenv)
             call ncf_readRealData(v,bbok,irc)
             if (irc.ne.0) then
                write(*,*)myname,'Error return from altid-readData.',irc
                return
             end if
          end if
       end if
       ! read reference time field into memory
       v=>file%ref%timid
       if (v%lend.le.0) then ! not in memory
          write(*,*)myname,'Reading variable:',v%var250(1:v%lenv)
          call ncf_readData(v,bbok,irc)
          if (irc.ne.0) then
             write(*,*)myname,'Error return from timid-readData.',irc
             return
          end if
          a => ncf_getAttribute(v,"units",irc)
          if (associated(a)) then
             buff250=ncf_getAttributeText(a)
             call chop0(buff250,250)
             lenb=length(buff250,250,10)
             !write(*,*)myname,"Analysis is in "//buff250(1:lenb), t2000
             if (buff250(1:4).eq."days") then ! convert days to seconds
                timfact=86400.0D0
             end if
          end if
       end if
       ! read analysis time field into memory
       v=>file%ref%tanid
       if (associated(v)) then
          if (v%lend.le.0) then ! not in memory
             write(*,*)myname,'Reading variable:',v%var250(1:v%lenv)
             call ncf_readData(v,bbok,irc)
             if (irc.ne.0) then
                write(*,*)myname,'Error return from altid-readData.',irc
                return
             end if
          end if
          a => ncf_getAttribute(v,"units",irc)
          if (associated(a)) then
             buff250=ncf_getAttributeText(a)
             call chop0(buff250,250)
             lenb=length(buff250,250,10)
             !write(*,*)myname,"Analysis is in "//buff250(1:lenb), t2000
             if (buff250(1:4).eq."days") then ! convert days to seconds
                tanfact=86400.0D0
             end if
          end if
       end if
    end if
    if (bok .and. associated(file%ref%xcoid)) then
       ! read x into memory
       v=>file%ref%xcoid
       bok=associated(v)
       write(*,*)myname,'Reading variable:',v%var250(1:v%lenv)
       call ncf_readData(v,bok,irc)
       if (irc.ne.0) then
          write(*,*)myname,'Error return from latid-readData.',irc
          return
       end if
    end if
    if (bok .and. associated(file%ref%ycoid)) then
       ! read y into memory
       v=>file%ref%ycoid
       bok=associated(v)
       write(*,*)myname,'Reading variable:',v%var250(1:v%lenv)
       call ncf_readData(v,bok,irc)
       if (irc.ne.0) then
          write(*,*)myname,'Error return from latid-readData.',irc
          return
       end if
    end if
    if (bok) then
       ! read gridid into memory
       v=>file%ref%gridid
       if (associated(v)) then
          !bok=associated(v)
          write(*,*)myname,'Reading variable:',v%var250(1:v%lenv)
          call ncf_readData(v,bok,irc)
          if (irc.ne.0) then
             write(*,*)myname,'Error return from gridid-readData.',irc
             irc=0
             bok=.false.
             !return
          end if
          !if (bok) then
          !   file%rok(3)=file%rok(3)+1
          !else
          !   file%rrm(3)=file%rrm(3)+1 ! contents error
          !end if
       end if
    end if
    ! read any filter fields into memory
    if (bok) then
       ! loop over reports, check for variables....
       write(*,*)myname,'Reading filter-variables.'
       cpar=>file%firstparameter%next
       do while (.not.associated(cpar,target=file%lastparameter))
          write(*,*)myname,'Reading parameter...'
          crep=>cpar%firstreport%next
          do while (.not.associated(crep,target=cpar%lastreport))
             ! write(*,*)myname,'Reading report...'
             call setActive(crep%roperation,irc)
             if (irc.ne.0) then
                write(*,*)myname,'No mask available.'
                irc=374
                return
             end if
             cfilter=>crep%firstfilter%next
             do while (.not. associated(cfilter,target=crep%lastfilter))
                ! write(*,*)myname,'Reading filter...'
                cfilter%i=>file%ref
                if (cfilter%ipar.and.cfilter%active) then
                   write(*,*)myname,'Loading:',trim(cfilter%var250)
                   call ncf_checkParameter(file%ref,cfilter%var250,bok,irc)
                   if (irc.ne.0) then
                      write(*,*)myname,'Error return from CHECKPARAMETER.',irc
                      return
                   end if
                   if (bok) then
                      cfilter%v => file%ref%parid
                      if (associated(cfilter%v)) then
                         write(*,*)myname,'Reading variable:',trim(cfilter%var250),&
                              & ' ',cfilter%v%var250(1:cfilter%v%lenv)
                         if (cfilter%type==flt_string) then
                            write(*,*)myname,'Reading variable:',cfilter%v%var250(1:cfilter%v%lenv)
                            call ncf_readData(cfilter%v,bok,irc)
                            if (irc.ne.0) then
                               write(*,*)myname,'Error return from readData.',irc
                               return
                            end if
                            cfilter%sdo=>ncf_newDimOrder(file%ref,irc)
                            if (irc.ne.0) then
                               write(*,*)myname,'Unable to create new dimension dimorder.',irc
                               return
                            end if
                            jj=ncf_getDimEntry(file%ref,cfilter%sdim80)
                            if (jj.le.0) then
                               write(*,*)myname,'Invalid dimension.',trim(cfilter%sdim80),jj
                               irc=834
                               return
                            end if
                            sd=>ncf_getInventoryDimension(file%ref,jj,irc)
                            if (irc.ne.0) then
                               write(*,*)myname,'Unable to get dimension.',irc,jj
                               return
                            end if
                            call ncf_addDimOrderDim(cfilter%sdo,sd,irc)
                            sd=>ncf_getInventoryDimension(file%ref,jj,irc)
                            if (irc.ne.0) then
                               write(*,*)myname,'Unable to get dimension.',irc,jj
                               return
                            end if
                            call ncf_addDimOrderDim(file%refStrDo,sd,irc)
                            !write(*,*)myname,">>>>> Filter dimension order:"
                            !call ncf_printDimOrder(cfilter%sdo)
                         else
                            !write(*,*)myname,'Reading variable:',trim(cfilter%var250)
                            write(*,*)myname,'Reading variable:',&
                                 & cfilter%v%var250(1:cfilter%v%lenv)
                            call ncf_readRealData(cfilter%v,bok,irc)
                            if (irc.ne.0) then
                               write(*,*)myname,'Error return from readData.',irc
                               return
                            end if
                         end if
                      else
                         write(*,*)myname,'Unable to read variable:',trim(cfilter%var250)
                      end if
                   else
                      write(*,*)myname,'Unable to find variable:',trim(cfilter%var250)
                   end if
                else if (len(trim(cfilter%var250)).gt.0) then
                   write(*,*)myname,'Filter variable ignored:',&
                        & trim(cfilter%var250),cfilter%ipar,cfilter%active
                end if
                if (cfilter%type==flt_dimension) then ! only interested in the dimensions
                   jj=ncf_getDimEntry(file%ref,cfilter%sdim80)
                   if (jj.le.0) then
                      write(*,*)myname,'Invalid dimension.',trim(cfilter%sdim80),jj
                      irc=834
                      return
                   end if
                   sd=>ncf_getInventoryDimension(file%ref,jj,irc)
                   if (irc.ne.0) then
                      write(*,*)myname,'Unable to get dimension.',irc,jj
                      return
                   end if
                   call ncf_addDimOrderDim(file%refDimDo,sd,irc)
                end if
                cfilter=>cfilter%next
             end do
             crep=>crep%next
          end do
          cpar=>cpar%next
       end do
    end if
    !
    ! loop over requested variables, make parid-array and parAll index
    if (bok) then
       write(*,*)myname,'Reading request-variables.'
       call ncf_clearDimOrder(file%refAllDO)
       bok=.false.
       if (file%npar.eq.0) then
          write(*,*)myname,'No parameters requested.'
       end if
       cpar=>file%firstparameter%next
       do while (.not.associated(cpar,target=file%lastparameter))
          nullify(file%ref%parid)
          bbok=.true.
          if (bbok) then
             call ncf_checkParameter(file%ref,cpar%par350,bbok,irc)
             if (irc.ne.0) then
                write(*,*)myname,'Error return from checkContents.',irc
                return
             end if
             if (bbok) then
                file%rok(3)=file%rok(3)+1
             else
                file%rrm(3)=file%rrm(3)+1 ! contents error
             end if
          end if
          ! read field into memory
          if (bbok) then
             v => file%ref%parid
             ! read parameter field into memory
             if (v%lend.le.0) then ! not in memory
                write(*,*)myname,'Reading variable:',v%var250(1:v%lenv)
                call ncf_readRealData(v,bbok,irc)
                if (irc.ne.0) then
                   write(*,*)myname,'Error return from readData.',irc
                   return
                end if
             end if
             ! get "accumulation_hours" if any
             a => ncf_getAttribute(v,"accumulation_hours",irc)
             if (associated(a)) then
                buff250=ncf_getAttributeText(a)
                call chop0(buff250,250)
                lenb=length(buff250,250,10)
                read (buff250(1:lenb),*,iostat=irc)hrs ! accumulation hours
                if (irc.ne.0) then
                   write(*,*)myname,"Unable to read attribute 'accumulation_hours':'"&
                        & //buff250(1:lenb)//"'"
                   return
                end if
             else
                hrs=0.0D0
             end if
          end if
          if (bbok) then
             file%refParDO=>ncf_makeDimOrder(file%ref%parid,irc)
             if (irc.ne.0) then
                write(*,*) myname,'Error return from makeDimOrder (parid).',irc
                return
             end if
             if (.not.associated(file%refAllDO)) then
                file%refAllDO => ncf_copyDimOrder(file%refParDO,irc)
                if (irc.ne.0) then
                   write(*,*) myname,'Error return from copyDimOrder.',irc
                   return
                end if
             else
                call ncf_addDimOrder(file%refAllDO,file%refParDO,irc)
                if (irc.ne.0) then
                   write(*,*) myname,'Error return from addDimOrder.',irc
                   return
                end if
             end if
             cpar%var=>file%ref%parid
             cpar%hrs=hrs
             bok=.true.
          end if
          if (.not.bbok) then
             lenc=length(cpar%par350,350,10)
             write(*,*)myname,'Ignoring parameter:',cpar%par350(1:lenc)
          end if
          cpar=>cpar%next
       end do
    end if
    return
  end subroutine readDataFile
  !
  subroutine extractTimes(file,bok,irc)
    implicit none
    type(filetype) :: file
    logical bok
    integer irc
    integer :: timEntry
    type(dimension), pointer :: timdim=>null()
    type(variable), pointer :: v
    type(report), pointer :: crep
    type(parameter), pointer :: cpar,bpar
    real :: dt;
    integer :: tt,ii,lenr
    integer, external :: length
    !
    CHARACTER*14 MYNAME 
    DATA MYNAME /'getTimeInfo'/
    file%firstt=.true.
    if (bok) then
       file%mint2000=j2000(timfact*file%ref%timid%fd(1))
       file%maxt2000=j2000(timfact*file%ref%timid%fd(file%ref%timid%lend))
       dt=file%maxt2000 -file%mint2000
       if (file%maxdays > 0.0D0 .and. abs(dt) > file%maxdays) then ! sanity check
          ! this happens when input file is not ready...
          lenr=length(file%ref350,350,10)
          write(*,'(X,A,A,A,A,F0.3,A,F0.3)')myname,"Corrupted input file:",&
               & file%ref350(1:lenr),"; Dt=",dt,">",file%maxdays
          do ii=1,file%ref%timid%lend
             write(*,'(X,A,A,I0,A,F0.1,A,F0.3)')myname,"time(",II,") = ",file%ref%timid%fd(II),&
                  & " ; JD2000= ",j2000(timfact*file%ref%timid%fd(II))
          end do
          irc=333
          return
       end if
       if (file%keep > 0 .or. file%ref%timid%lend.le.1) then
          dt=file%keep/24.0D0
       else
          dt=j2000(timfact*file%ref%timid%fd(file%ref%timid%lend))-&
               & j2000(timfact*file%ref%timid%fd(max(file%ref%timid%lend-1,1)))
       end if
       dt=max(0.0D0,min(1.0D0,dt*0.5D0));
       file%tt2000=file%maxt2000 + dt
       file%firstt=.false.
    end if
    if (associated(file%ref%timid)) then
       file%mtime=file%ref%timid%lend
    else
       file%mtime=1
    end if
    if (associated(file%i)) then
       file%mpst=file%i%lend
    else
       file%mpst=1
    end if
    if (.not.associated(file%refTimDO)) then
       write(*,*)myname,"Missing refTimDO..."
       bok=.false.
       irc=273
       return
    end if
    file%mrest=0
    timEntry=min(mtim,ncf_getDimEntry(file%ref,"time"))
    timdim => ncf_getInventoryDimension(file%ref,timEntry,irc) ! get dimension
    !write(*,*)myname,'Time:',timEntry,associated(timdim)
    cpar=>file%firstparameter%next
    do while (.not.associated(cpar,target=file%lastparameter))
       v => cpar%var ! variable
       if (associated(v)) then
          if (ncf_hasDimension(v,timdim,irc)) then
             file%mrest=max(file%mrest,v%lend/file%mtime)
          else
             file%mrest=max(file%mrest,v%lend)
          end if
       end if
       ! loop over times
       call ncf_resetPos(file%refTimDO,irc)
       if (irc.ne.0) then
          write(*,*) myname,'Error return from resetPos (file%refLatLon).',irc
          return
       end if
       do while (ncf_increment(file%ref,file%refTimDO,irc))
          tt=max(1,min(mtim,file%ref%pos%pos(timEntry)))
          file%t2000=j2000(timfact*ncf_valuePosition(file%ref%timid,irc))
          if (irc.ne.0) then
             write(*,*) myname,'Error return from ncf_valuePosition.',irc
             return
          end if
          ! loop over reports
          crep => cpar%firstreport%next
          do while (.not.associated(crep,target=cpar%lastreport))
             crep%tj2000(tt)=file%t2000
             crep => crep%next
          end do
       end do
       cpar=>cpar%next
    end do
    return
  end subroutine extractTimes
  !
  subroutine matchAux(file,crep,irc)
    implicit none
    type(filetype) :: file
    type(report), pointer :: crep
    integer :: irc
    type(parameter), pointer :: cpar,bpar
    integer :: lenx
    character*12 :: myname
    data myname /'matchAux'/
    if (crep%laux) then
       nullify(crep%vaux)
       bpar=>file%firstparameter%next
       PARLOOP:do while (.not.associated(bpar,target=file%lastparameter))
          if (bpar%par350.eq.crep%aux700(2)(1:350)) then
             crep%vaux=>bpar%var
             lenx=length(crep%aux700(2),700,10)
             !write(*,*)myname,'Auxiliary:"'//crep%aux700(2)(1:lenx)//'"'
             exit PARLOOP
          end if
          bpar=>bpar%next
       end do PARLOOP
       if (.not.associated(crep%vaux)) then
          lenx=length(crep%aux700(2),700,10)
          write(*,*)myname,'*** No auxiliary defined for "'//&
               & crep%aux700(2)(1:lenx)//'"'
          irc=348
          return
       end if
    end if
  end subroutine matchAux
  !
  subroutine matchAuxs(file,irc)
    implicit none
    type(filetype) :: file
    integer :: irc
    character*12 myname
    data myname/'matchAuxs'/
    type(report), pointer :: crep
    type(parameter), pointer :: cpar
    !
    cpar=>file%firstparameter%next
    do while(.not.associated(cpar,target=file%lastparameter))
       crep=>cpar%firstreport%next
       do while (.not.associated(crep,target=cpar%lastreport))
          call matchAux(file,crep,irc)
          if (irc.ne.0) then
             write(*,*)myname,'Error return from mathAux.',irc
             return
          end if
          crep=>crep%next
       end do
       cpar=>cpar%next
    end do
    !
    return
  end subroutine matchAuxs
  !
  subroutine writeTimes(file,irc)
    implicit none
    type(filetype) :: file
    integer :: irc
    integer :: yy,mm,dd,hh,mi
    real :: sec
    character*4 ayy
    character*2 amm,add,ahh
    !real xissued
    CHARACTER*14 MYNAME 
    DATA MYNAME /'writeTimes'/
    file%a2000=file%t2000
    call dj2000(file%a2000,yy,mm,dd,hh,mi,sec)
    write (file%a24,'(I4.4,"-",I2.2,"-",I2.2,"_",I2.2,"-",I2.2,"-00.000Z")') &
         &yy,mm,dd,hh,mi
    write (ayy,'(I4.4)') yy
    write (amm,'(I2.2)') mm
    write (add,'(I2.2)') dd
    write (ahh,'(I2.2)') hh
    write(*,*)myname,'Analysis time:   '//file%a24
    ! xissued=f1970(yy,mm,dd,hh,mi,sec)
    if (file%firstt) then
       file%t24="NotAvailable";
       file%s24="NotAvailable";
       file%e24="NotAvailable";
    else
       call dj2000(file%mint2000,yy,mm,dd,hh,mi,sec)
       write (file%s24,'(I4.4,"-",I2.2,"-",I2.2,"_",I2.2,"-",I2.2,"-00.0000")') &
            &yy,mm,dd,hh,mi
       call dj2000(file%maxt2000,yy,mm,dd,hh,mi,sec)
       write (file%e24,'(I4.4,"-",I2.2,"-",I2.2,"_",I2.2,"-",I2.2,"-00.0000")') &
            &yy,mm,dd,hh,mi
       call dj2000(file%tt2000,yy,mm,dd,hh,mi,sec)
       write (file%t24,'(I4.4,"-",I2.2,"-",I2.2,"_",I2.2,"-",I2.2,"-00.000Z")') &
            &yy,mm,dd,hh,mi

    end if
    !
    write(*,*)myname,'Data start time: '//file%s24
    write(*,*)myname,'Data end time:   '//file%e24
    write(*,*)myname,'Expiration time: '//file%t24
    return
  end subroutine writeTimes
  !
  subroutine processKeys(file,irc)
    implicit none
    type(filetype) :: file
    integer :: irc
    type(parameter), pointer :: cpar,bpar
    type(report), pointer :: crep
    integer :: lenx
    CHARACTER*14 MYNAME 
    DATA MYNAME /'processKeys'/
    cpar=>file%firstparameter%next
    do while (.not.associated(cpar,target=file%lastparameter))
       ! loop over reports
       crep=>cpar%firstreport%next
       do while (.not.associated(crep,target=cpar%lastreport))
          ! make report independent keys
          call setKeyVar(file,mkeyvar,cpar%par350,crep%keyvar350)
          ! make static macros
          call setXmlVar(cpar,crep,file,mxmlvar,mtim,mpst,crep%xmlvar350)
          crep=>crep%next
       end do
       cpar=>cpar%next
    end do
    return
  end subroutine processKeys
  !
  subroutine processDataFile(file,fail,bok,irc)
    implicit none
    type(filetype) :: file
    logical :: fail(4)
    logical :: bok
    integer :: irc
    integer :: timEntry
    real val,aux
    logical :: used
    type(report), pointer :: crep
    type(parameter), pointer :: cpar,bpar
    type(variable), pointer :: v
    logical masked,bbok
    integer loc, npst, ii, jj
    integer ecnt
    integer :: newnn,minn,tt
    real :: eps=1.0D-10
    logical :: uniq=.false.
    CHARACTER*16 MYNAME 
    DATA MYNAME /'processDataFile'/
    ecnt=0
    minn=-1
    file%dt=0.0D0
    if (bok) then ! use filter
       write(*,*) 'Using input mask.'
       timEntry=min(mtim,ncf_getDimEntry(file%ref,"time"))
       !
       ! make index of outer dimensions in reference
       !
       file%refOut => ncf_copyDimOrder(file%refAllDO,irc)
       if (irc.ne.0) then
          write(*,*) myname,'Error return from copyDimOrder.',irc
          return
       end if
       call ncf_removeDimOrder(file%refOut,file%refLatLonAltDO)
       !write(*,*) myname,'RefDim:'
       !call ncf_printDimOrder(file%refDimDo)
       !write(*,*) myname,'RefStr:'
       !call ncf_printDimOrder(file%refStrDo)
       !write(*,*) myname,'ReflatLon:'
       !call ncf_printDimOrder(file%refLatLonAltDO)
       write(*,'(X,A,A,I0,A,I0)') myname,&
            & '>>> Max size=',file%mrest," times=",file%mtime
       ! make iteration dimension order...
       call ncf_clearDimOrder(file%refIterDO)
       if (file%leni.gt.0) then ! we have a variable
          npst=min(mpst,ncf_getDimEntry(file%ref,file%iter80(1:file%leni)))
          file%i => ncf_getVariable(file%ref,file%iter80(1:file%leni),bbok,irc)
          if (.not.bbok.or.irc.ne.0) then
             write(*,*)myname,"Unable to find ITERATION variable:",file%iter80(1:file%leni)
             irc=347
             return
          end if
          ! read values into memory
          call ncf_readRealData(file%i,bbok,irc)
          if (.not.bbok.or.irc.ne.0) then
             write(*,*)myname,"Unable to read ITERATION variable:",file%iter80(1:file%leni)
             irc=348
             return
          end if
       else
          npst=1
          bbok=.false.
       end if
       if (bbok) then
          file%refIterDO => ncf_makeDimOrder(file%i,irc)
          call ncf_removeDimOrder(file%refOut,file%refIterDO)
       else
          file%refIterDO => ncf_newDimOrder(file%ref,irc) ! empty dimOrder
       end if
       !
       file%refInn => ncf_copyDimOrder(file%refOut,irc)
       call ncf_removeDimOrder(file%refInn,file%refDimDO)
       call ncf_removeDimOrder(file%refOut,file%refInn)
       write(*,*) myname,'>>> Outer loop dimensions:'
       call ncf_printDimOrder(file%refOut)
       write(*,*) myname,'>>> Inner loop dimensions:'
       call ncf_printDimOrder(file%refInn)
       ! allocate trg-arrays (time*parameters*grid-size)... XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
       call initFileKeys(file,irc)
       if (irc.ne.0) then
          write(*,*)myname,'Error return from initKeys.',irc
          return
       end if
       if (timfact*file%ref%timid%lend.ge.2) then
          file%dt=(j2000(timfact*file%ref%timid%fd(2))-&
               & j2000(timfact*file%ref%timid%fd(1)))*0.5D0
       else
          file%dt=1.0D0
       end if
       write(*,*)myname,'Dt=',file%dt
       !
       ! loop over iteration dimension
       !
       call ncf_resetPos(file%refIterDO,irc)
       if (irc.ne.0) then
          write(*,*) myname,'Error return from resetPos (file%refIterDO).',irc
          return
       end if
       ITER:do while (ncf_increment(file%ref,file%refIterDO,irc))
          ii=min(mpst,ncf_getLocation(file%i))
          jj=nint(ncf_valuePosition(file%i,irc))
          !
          ! loop over output grid and match grid points
          !
          write(*,*)myname,'Applying filter.'
          call ncf_resetPos(file%refLatLonAltDO,irc)
          if (irc.ne.0) then
             write(*,*) myname,'Error return from resetPos (file%refLatLon).',irc
             return
          end if
          do while (ncf_increment(file%ref,file%refLatLonAltDO,irc))
             lat=ncf_valuePosition(file%ref%latid,irc)
             if (irc.ne.0) then
                write(*,*) myname,'Error return from valuePosition (latid).',irc
                return
             end if
             lon=ncf_valuePosition(file%ref%lonid,irc)
             if (irc.ne.0) then
                write(*,*) myname,'Error return from valuePosition (lonid).',irc
                return
             end if
             if (associated(file%ref%altid)) then
                alt=ncf_valuePosition(file%ref%altid,irc)
                if (irc.ne.0) then
                   write(*,*) myname,'Error return from valuePosition (altid).',irc
                   return
                end if
             else
                alt=0.0D0
             end if
             !
             ! loop over parameters...
             cpar=>file%firstparameter%next
             PARR:do while (.not.associated(cpar,target=file%lastparameter))
                v => cpar%var ! variable
                if (.not.associated(v)) then
                   v=>v%next
                   cycle PARR
                end if
                used=.false.
                ! loop over reports...
                crep=>cpar%firstreport%next
                REPP:do while (.not.associated(crep,target=cpar%lastreport))
                   if (associated(crep%roperation)) then
                      ! loop over dimension that the filter depends on...
                      call ncf_resetPos(file%refOut,irc)
                      if (irc.ne.0) then
                         write(*,*) myname,'Error return from resetPos (file%refOut).',irc
                         return
                      end if
                      do while (ncf_increment(file%ref,file%refOut,irc))
                         ! write(*,*)myname,'Position:',lat,lon,alt
                         ! call printMask(crep%roperation,0)
                         ! calculate the ignore-data-flag based on the report mask...
                         masked=checkMasked(crep%roperation,lat,lon,alt,irc)
                         if (irc.ne.0) then
                            write(*,*) myname,'Error return from checkMasked.',irc
                            return
                         end if
                         if (.not.masked) then ! use this value
                            used=.true.
                            if (file%firsttrg) then
                               file%firsttrg=.false.
                               file%refLatlonDo => ncf_copyDimOrder(file%refLatDo,irc)
                               if (irc.ne.0) then
                                  write(*,*) myname,'Error return from copyDimOrder.',irc
                                  return
                               end if
                               call ncf_addDimOrder(file%refLatlonDo,file%refLonDo,irc)
                               if (irc.ne.0) then
                                  write(*,*) myname,'Error return from addDimOrder.',irc
                                  return
                               end if
                               if (crep%ltrg) then
                                  file%ix=>ncf_getdimensionOrderDimension(file%refLatlonDo,1)
                                  file%iy=>ncf_getdimensionOrderDimension(file%refLatlonDo,2)
                                  file%darea=ncf_getArea(file%ref,file%ix,file%iy,irc)
                                  if (irc.ne.0) then
                                     write(*,*) myname,'Error return from ncf_getArea.',irc
                                     return
                                  end if
                               end if
                               call ncf_clearDimOrder(file%refLatLonDO)
                               write(*,'(X,A,A,F0.2,A)')myname,&
                                    & 'Grid point area = ',file%darea,' km**2'
                            end if
                            call ncf_resetPos(file%refInn,irc)
                            if (irc.ne.0) then
                               write(*,*) myname,'Error return from resetPos (refOut).',irc
                               return
                            end if
                            !call ncf_printDimOrder(file%refInn)
                            do while (ncf_increment(file%ref,file%refInn,irc))
                               tt=max(1,min(mtim,file%ref%pos%pos(timEntry)))
                               ! make iteration value
                               write(crep%xmlvar350(xml_iter,tt,ii),"(I0)") jj
                               call chop0(crep%xmlvar350(xml_iter,tt,ii),350)
                               !
                               val=ncf_valuePosition(v,irc)
                               ! call ncf_printpos(v%f%pos)
                               !write(*,*) "                    Value=",val
                               if (val.ne.nf_fill_double) then
                                  !write(*,*) "                    Ok value=",val
#ifdef JNK                             
                                  loc=ncf_getLocation(v)
                                  write(50,'(I10,3(X,F10.5),X,I5,X,A)')loc,val, &
                                       & lat,lon,tt,v%var250(1:v%lenv)
#endif
                                  if (crep%ltrg) then
                                     crep%nkey1(tt,ii)=crep%nkey1(tt,ii)+1
                                     crep%nrest=max(crep%nrest,crep%nkey1(tt,ii))
                                     crep%arest=max(crep%arest,crep%nkey1(tt,ii)+crep%nkey0(tt,ii))
                                     if (crep%nkey1(tt,ii).gt.crep%mrest) then
                                        if (ecnt.lt.10) then
                                           ecnt=ecnt+1
                                           write(*,'(X,A,A,I0,A,I0,A)')myname,&
                                                & '*** Too small report size: ',&
                                                & crep%mrest," (time step=",tt,")"
                                        else if (ecnt.eq.10) then
                                           ecnt=ecnt+1
                                           write(*,'(X,A,A)')myname,'*** ...'
                                        end if
                                        fail(fail_size)=.true.
                                        bok=.false.
                                     else
                                        crep%key1(crep%nkey1(tt,ii),tt,ii)=val
                                        crep%keyind(crep%nkey1(tt,ii),tt,ii)=crep%nkey1(tt,ii)
                                     end if
                                  else
                                     crep%nkey0(tt,ii)=crep%nkey0(tt,ii)+1
                                  end if
                                  !
                                  !write(*,*)myname,'Value:',val,v%var250(1:v%lenv),&
                                  !     & tt,crep%ltrg
                                  !call ncf_printVarPos(v)
                                  crep%ntim=max(crep%ntim,tt,ii)
                                  if (crep%ntim .gt. mtim) then
                                     write(*,*)myname,'Too many times.',mtim
                                     irc=457
                                     return
                                  end if
                                  if (crep%lfirst(tt,ii)) then
                                     crep%lfirst(tt,ii)=.false.
                                     crep%valavg(tt,ii)=val
                                     crep%valcnt(tt,ii)=1.0
                                     crep%valmin(tt,ii)=val
                                     crep%valmax(tt,ii)=val
                                     crep%llmin(1,tt,ii)=lat
                                     crep%llmax(1,tt,ii)=lat
                                     crep%llmin(2,tt,ii)=lon
                                     crep%llmax(2,tt,ii)=lon
                                     crep%ttmin(tt,ii)=tt
                                     crep%ttmax(tt,ii)=tt
                                     ! process auxiliaries
                                     if (crep%laux) then
                                        aux=ncf_valuePosition(crep%vaux,irc)
                                        crep%auxmax(tt,ii)=aux
                                        crep%auxmin(tt,ii)=aux
                                     end if
                                  else
                                     crep%valavg(tt,ii)=crep%valavg(tt,ii)+val
                                     crep%valcnt(tt,ii)=crep%valcnt(tt,ii)+1.0
                                     if (val.gt.crep%valmax(tt,ii)) then
                                        ! write(*,'(X,A,X,I4,X,F10.3,X,I8)')myname//&
                                        !      & 'Found new max:',tt,val,loc
                                        crep%valmax(tt,ii)=val
                                        crep%llmax(1,tt,ii)=lat
                                        crep%llmax(2,tt,ii)=lon
                                        crep%ttmax(tt,ii)=tt
                                     end if
                                     if (val.lt.crep%valmin(tt,ii)) then
                                        crep%valmin(tt,ii)=val
                                        crep%llmin(1,tt,ii)=lat
                                        crep%llmin(2,tt,ii)=lon
                                        crep%ttmin(tt,ii)=tt
                                     end if
                                     ! process auxiliaries
                                     if (crep%laux) then
                                        aux=ncf_valuePosition(crep%vaux,irc)
                                        if (val.gt.crep%auxmax(tt,ii)) then
                                           crep%auxmax(tt,ii)=aux
                                        end if
                                        if (val.lt.crep%auxmin(tt,ii)) then
                                           crep%auxmin(tt,ii)=aux
                                        end if
                                     end if
                                  end if
                               else
                                  crep%nkey0(tt,ii)=crep%nkey0(tt,ii)+1
                               end if
                            end do ! inner
                            if (irc.ne.0) then
                               write(*,*) myname,'Error return from increment (refInn).',irc
                               return
                            end if
                         end if ! masked-block
                      end do ! outer
                      if (irc.ne.0) then
                         write(*,*) myname,'Error return from increment (refOut).',irc
                         return
                      end if
                   end if
                   crep=>crep%next
                end do REPP
                if (.not.used) then ! mark value not unused in mask-file
                   ! loop over dimension that the filter depends on...
                   call ncf_resetPos(file%refOut,irc)
                   if (irc.ne.0) then
                      write(*,*) myname,'Error return from resetPos (file%refOut).',irc
                      return
                   end if
                   do while (ncf_increment(file%ref,file%refOut,irc))
                      call ncf_resetPos(file%refInn,irc)
                      if (irc.ne.0) then
                         write(*,*) myname,'Error return from resetPos (refOut).',irc
                         return
                      end if
                      do while (ncf_increment(file%ref,file%refInn,irc))
                         call ncf_setValue(v,-999.99D0,irc) 
                         !call ncf_setValue(v,nf_fill_double,irc) 
                         if (irc.ne.0) then
                            write(*,*) myname,'Error return from setValue.',irc
                            return
                         end if
                      end do
                   end do
                else
                   !write(*,*)myname,'Keeping:',lat,lon
                end if
                cpar=>cpar%next
             end do PARR
          end do ! latlon
          ! sort the data...
          cpar=>file%firstparameter%next
          do while (.not.associated(cpar,target=file%lastparameter))
             v => cpar%var ! variable
             crep=>cpar%firstreport%next
             do while (.not.associated(crep,target=cpar%lastreport))
                if (crep%ltrg) then
                   do tt=1,file%mtime
                      if (crep%nkey1(tt).le.crep%mrest) then
                         call heapsort1(crep%mrest,crep%key1(1,tt),newnn,crep%nkey1(tt),&
                              & crep%keyind(1,tt),eps,uniq)
                         if (newnn.gt.0.and. (minn.lt.0 .or. minn.gt.newnn)) then
                            minn=newnn
                         end if
                      end if
                   end do
                end if
                crep=>crep%next
             end do
             cpar=>cpar%next
          end do
       end do ITER
       if (minn.ne.-1) then
          write(*,'(X,A,A,I0,A,F0.2,A)')myname,&
               & 'Grid points in mask = ',minn,'  ( ',&
               & real(minn)*file%darea,' km**2 )'
       end if
       if (irc.ne.0) then
          write(*,*) myname,'Error return from increment (refLatLonOut).',irc
          return
       end if
       if (associated(file%ref%tanid)) then
          file%t2000=j2000(tanfact*ncf_valuePosition(file%ref%tanid,irc))
          if (irc.ne.0) then
             write(*,*) myname,'Error return from ncf_valuePosition.',irc
             return
          end if
       else
          file%t2000=j2000(timfact*file%ref%timid%fd(1)) - file%cutoff/24.0D0
       end if
    end if     ! bok
    return
  end subroutine processDataFile
  !
  subroutine sortTargetData(file,irc)
    implicit none
    type(filetype) :: file
    integer :: irc
    type(variable), pointer  :: v
    type(report), pointer    :: crep
    type(parameter), pointer :: cpar
    integer :: newnn,minn,tt
    real :: eps=1.0D-10
    logical :: uniq=.false.
    CHARACTER*14 MYNAME 
    DATA MYNAME /'sortTargetData'/
    minn=-1
    cpar=>file%firstparameter%next
    do while (.not.associated(cpar,target=file%lastparameter))
       v => cpar%var ! variable
       crep=>cpar%firstreport%next
       do while (.not.associated(crep,target=cpar%lastreport))
          if (crep%ltrg) then
             do tt=1,file%mtime
                if (crep%nkey1(tt,ii).le.crep%mrest) then
                   call heapsort1(crep%mrest,crep%key1(1,tt,ii),newnn,crep%nkey1(tt,ii),&
                        & crep%keyind(1,tt,ii),eps,uniq)
                   if (newnn.gt.0.and. (minn.lt.0 .or. minn.gt.newnn)) then
                      minn=newnn
                   end if
                end if
             end do
          end if
          crep=>crep%next
       end do
       cpar=>cpar%next
    end do
    if (minn.ne.-1) then
       write(*,'(X,A,A,I0,A,F0.2,A)')myname,&
            & 'Grid points in mask = ',minn,'  ( ',&
            & real(minn)*file%darea,' km**2 )'
    end if
    return
  end subroutine sortTargetData
  !
  subroutine checkExitCondition(file,fail,irc)
    implicit none
    type(filetype) :: file
    logical :: fail(3)
    integer :: irc
    type(parameter), pointer :: cpar
    type(variable), pointer :: v
    integer :: lenp
    character*700 :: b700
    integer cnt,cntud
    real :: maxval,minval
    CHARACTER*20 MYNAME 
    DATA MYNAME /'checkExitCondition'/
    ! global fail conditions...
    fail(fail_NoData)=.false.
    fail(fail_AnyData)=.false.
    fail(fail_None)=.false.
    !
    cpar=>file%firstparameter%next
    do while (.not.associated(cpar,target=file%lastparameter))
       v => cpar%var ! variable
       if (associated(v).and. (cpar%find.or.cpar%fiad.or.cpar%fino)) then
          !call ncf_printVariable(v)
          call ncf_countField(v,cnt,cntud,minval,maxval,irc)
          if (irc.ne.0) then
             write(*,*)myname,'Error return from COUNTFIELD.',irc
             return
          end if
          if (cnt.ne.0) file%nodata=.false.
          lenp=length(cpar%par350,350,10)
          if (cpar%find.and.cnt.eq.0) then
             fail(fail_NoData)=.true.
             write(b700,'("PAR Check=",A,";no data;FAIL;UNDEF=",I10,'//&
                  & '";MIN=",F17.10,";MAX=",F17.10)') &
                  &     cpar%par350(1:lenp),cntud,minval,maxval
          else if (cpar%fiad.and.cnt.gt.0) then
             fail(fail_AnyData)=.true.
             write(b700,'("PAR Check=",A,";cnt=",I0,";FAIL;UNDEF=",I10,'//&
                  & '";MIN=",F17.10,";MAX=",F17.10)') &
                  &     cpar%par350(1:lenp),cnt,cntud,minval,maxval
          else
             write(b700,'("PAR Check=",A,";cnt=",I0,";OK;UNDEF=",I10,'//&
                  & '";MIN=",F17.10,";MAX=",F17.10)') &
                  &     cpar%par350(1:lenp),cnt,cntud,minval,maxval
          end if
          call chop0(b700,700)
          lenb=length(b700,700,10)
          write(*,*)b700(1:lenb)
       end if
       cpar=>cpar%next
    end do
    return
  end subroutine checkExitCondition
  !
  subroutine hintReports(file,irc)
    implicit none
    type(filetype) :: file
    integer :: irc
    type(parameter),pointer :: cpar
    type(report),pointer :: crep
    CHARACTER*14 MYNAME 
    DATA MYNAME /'hintReports'/
    cpar=>file%firstparameter%next
    do while (.not.associated(cpar,target=file%lastparameter))
       crep=>cpar%firstreport%next
       do while (.not.associated(crep,target=cpar%lastreport))
          call hintReport(file,cpar,crep,irc)
          crep=>crep%next
       end do
       cpar=>cpar%next
    end do
    return
  end subroutine hintReports
  !
  subroutine hintReport(file,cpar,crep,irc)
    implicit none
    type(filetype) :: file
    type(parameter),pointer :: cpar
    type(report),pointer :: crep
    integer :: irc
    integer :: lenx,leni
    character*700 :: i700
    character*60 :: b60
    CHARACTER*14 MYNAME 
    DATA MYNAME /'hintReport'/
    if (.not.associated(crep)) then
       write(*,*)myname,'Missing report...'
       return
    end if
    call chop0(crep%xmlo350,350)
    lenx=length(crep%xmlo350,350,10)
    i700=crep%xmlo350(1:lenx)
    call chop0(i700,700)
    leni=length(i700,700,20)
    ! write(*,*) myname,'Buffer:',i700(1:leni)
    write(b60,'(2(A,I0))',iostat=irc) "Suggested size=",crep%mrest," Actual=",crep%arest
    if (irc.ne.0) then
       write(*,*)myname,'Unable to write size,',crep%nrest
       irc=993
       return
    end if
    if (crep%nrest.eq.0) then
       write(*,*) myname,'    '//i700(1:leni)
    else if (crep%nrest.gt.crep%mrest) then
       write(*,*) myname,'***'//" ("//trim(b60)//") "//i700(1:leni)
    else if (crep%arest.gt.crep%mrest) then
       write(*,*) myname,'+++'//" ("//trim(b60)//") "//i700(1:leni)
    else
       write(*,*) myname,'   '//" ("//trim(b60)//") "//i700(1:leni)
    end if
    return
  end subroutine hintReport
  !
  subroutine writeReports(file,irc)
    implicit none
    type(filetype) :: file
    integer :: irc
    type(parameter),pointer :: cpar
    type(report),pointer :: crep
    CHARACTER*14 MYNAME 
    DATA MYNAME /'writeReports'/
    cpar=>file%firstparameter%next
    do while (.not.associated(cpar,target=file%lastparameter))
       crep=>cpar%firstreport%next
       do while (.not.associated(crep,target=cpar%lastreport))
          call writeReport(file,cpar,crep,irc)
          crep=>crep%next
       end do
       cpar=>cpar%next
    end do
    return
  end subroutine writeReports
  !
  subroutine writeReport(file,cpar,crep,irc)
    implicit none
    type(filetype) :: file
    type(parameter),pointer :: cpar
    type(report),pointer :: crep
    integer :: irc
    character*25 x25,y25,z25,l25,d25
    integer lenx25,leny25,lenz25,lenl25,lend25
    integer :: yy,mm,dd,hh,mi
    real :: sec
    real :: val
    character*4 ayy
    character*2 amm,add,ahh
    character*700 :: keb700,i700
    character*60 :: b60
    integer :: cpos,opos,lenx,leni,lenk,lenb,lenk1,lenk2
    integer :: iepos,ifpos,idd,lenv,ilenv,ii
    character*30 :: val30
    integer, external :: length
    real :: epos,fpos,trg
    real :: rpos,dpos
    integer,dimension(8) :: values
    CHARACTER*14 MYNAME 
    DATA MYNAME /'writeReport'/
    if (.not.associated(crep)) then
       write(*,*)myname,'Missing report...'
       return
    end if
    call chop0(crep%xmlo350,350)
    lenx=length(crep%xmlo350,350,10)
    i700=crep%xmlo350(1:lenx)
    call chop0(i700,700)
    leni=length(i700,700,20)
    ! write(*,*) myname,'Buffer:',i700(1:leni)
    lenb=0
    opos=1
    cpos=1
    write(b60,'(2(A,I0))',iostat=irc) "Suggested size=",crep%mrest," Actual=",crep%arest
    if (irc.ne.0) then
       write(*,*)myname,'Unable to write size,',crep%nrest
       irc=993
       return
    end if
    b700="";
    do while (cpos.le.leni)
       if (i700(cpos:cpos).eq."@") then ! first "@"
          b700=b700(1:lenb)//i700(opos:cpos-1)
          lenb=lenb+max(0,cpos-opos)
          ! find next "$" if any
          cpos=cpos+1
          opos=cpos
          do while (cpos.lt.leni.and.i700(cpos:cpos).ne."@") ! second "$"
             cpos=cpos+1
          end do
          if (i700(opos:cpos-1).eq."issued") then
             b700=b700(1:lenb)//file%a24
             lenb=lenb+24
             opos=cpos+1 ! point to character after "@"
          else  
             opos=opos-1 ! reset opos to first "@"
          end if
       end if
       !write(*,*) myname,' BUFF:::',cpos,leni,i700(cpos:cpos)
       cpos=cpos+1
    end do
    b700=b700(1:lenb)//i700(opos:cpos-1) ! copy the rest
    lenb=lenb+max(0,cpos-opos)
    i700=b700(1:lenb)
    call chop0(i700,700)
    leni=length(i700,700,10)
    !
    ! write to xml-file
    !
    unitx=ftunit(irc)
    if (irc.ne.0) then
       write(*,*)myname,'Error return from ftunit.',irc
       return
    end if
    if (crep%nrest.eq.0) then
       write(*,*) myname," "//i700(1:leni)
    else
       write(*,*) myname,"("//trim(b60)//") "//i700(1:leni)
    end if
    open(unit=unitx,file=i700(1:leni),STATUS="UNKNOWN", FORM="FORMATTED",iostat=irc)
    if (irc.ne.0) then
       write(*,*)myname,'Unable to open: ',i700(1:leni)
       return
    end if
    !
    write(unitx,"(A)",iostat=irc) "<xweather>"
    if (irc.ne.0) then
       write(*,*)myname,'Error writing to:',unitx
       return
    end if
    ! write date and time of execution
    call date_and_time(VALUES=values)
    yy=values(1) ! year
    mm=values(2) ! month
    dd=values(3) ! day
    hh=values(5) ! hour
    mi=values(6) ! minutes
    sec=real(values(7))+real(values(8))/1000.0D0 ! seconds
    call jd2000(file%i2000,yy,mm,dd,hh,mi,sec)
    file%i2000=file%i2000-real(values(4))/1440.0d0 ! time zone
    call dj2000(file%i2000,yy,mm,dd,hh,mi,sec)
    write (file%i24,'(I4.4,"-",I2.2,"-",I2.2,"_",I2.2,"-",I2.2,"-00.000Z")') yy,mm,dd,hh,mi
    write(unitx,'(A)',advance='no',iostat=irc) ' <time run="'//file%i24
    if (bok) then
       write(unitx,'(A)',advance='no',iostat=irc) '" issued="'//file%a24
    end if
    if (file%keep > 0.0D0) then
       write(unitx,'(A)',advance='no',iostat=irc) '" expires="'//file%t24
    end if
    write(unitx,'(A)',iostat=irc) '"/>'
    !
    if (file%nodata) then
       write(unitx,'(A)',iostat=irc) ' <parameter>'
       write(unitx,'(A)',iostat=irc) '   <warning '
       write(unitx,'(A)',iostat=irc) '      type="No valid grid inside mask"'
       write(unitx,'(A)',iostat=irc) '      level="0"'
       if (file%firstt) then
          file%a2000=file%I2000
          write (file%a24,'(I4.4,"-",I2.2,"-",I2.2,"_",I2.2,"-",I2.2,"-00.000Z")') &
               & yy,mm,dd,hh,mi
          write (ayy,'(I4.4)') yy
          write (amm,'(I2.2)') mm
          write (add,'(I2.2)') dd
          write (ahh,'(I2.2)') hh
          file%s24=file%a24
          file%t2000=file%t2000+1.0D0
          call dj2000(file%t2000,yy,mm,dd,hh,mi,sec)
          write (file%e24,'(I4.4,"-",I2.2,"-",I2.2,"_",I2.2,"-",I2.2,"-00.000Z")') &
               & yy,mm,dd,hh,mi
       end if
       write(unitx,'(A)',iostat=irc) '      time_issued="'//file%a24//'"'
       write(unitx,'(A)',iostat=irc) '      time_expires="'//file%t24//'"'
       write(unitx,'(A)',iostat=irc) '      time_start="'//file%s24//'"'
       write(unitx,'(A)',iostat=irc) '      time_stop="'//file%e24//'"'
       write(unitx,'(A)',iostat=irc) '   />'
       write(unitx,'(A)',iostat=irc) ' </parameter>'
    else 
       ! write data to xml-file here...
       write(unitx,'(A)',iostat=irc) ' <data>'
       lenp=length(cpar%par350,250,10)
       if (crep%nkey.eq.0) then
          write(unitx,'(A)',iostat=irc) '  <par name="'//cpar%par350(1:lenp)//'">'
       else 
          write(unitx,'(A)',iostat=irc) '  <parameter name="'//cpar%par350(1:lenp)//'">'
       end if
       ! write keys
       lenk=0
       keb700=''
       do kk=1,crep%nkey
          lenk1=length(crep%key700(1,kk),700,10)
          lenk2=length(crep%key700(2,kk),700,10)
          if (lenk+4+lenk1+lenk2.gt.700) cycle ! well... dont use too many keys...
          keb700(lenk+1:lenk+1)=" "
          lenk=lenk+1
          keb700(lenk+1:lenk+lenk1)=crep%key700(1,kk)(1:lenk1)
          lenk=lenk+lenk1
          keb700(lenk+1:lenk+2)="='"
          lenk=lenk+2
          keb700(lenk+1:lenk+lenk2)=crep%key700(2,kk)(1:lenk2)
          lenk=lenk+lenk2
          keb700(lenk+1:lenk+1)="'"
          lenk=lenk+1
          ! write(*,*) myname,"KEB700:",kk,keb700(1:lenk)
       end do
       call replaceKEY(keb700,mkeyvar,crep%keyvar350)
       lenk=length(keb700,700,10)
       ! write(*,*) '   '//keb700(1:lenk)
       ! write time data
       if (crep%nkey.ne.0) then
          write(unitx,'(A)',iostat=irc) &
               & "   <key "//keb700(1:lenk)//" />"
       end if
       call writeRecords(unitx,file,cpar,crep,irc)
       if (crep%nkey.eq.0) then
          write(unitx,'(A)',iostat=irc) '  </par>'
       else
          write(unitx,'(A)',iostat=irc) '  </parameter>'
       end if
       write(unitx,'(A)',iostat=irc) ' </data>'
    end if
    write(unitx,"(A)",iostat=irc) "</xweather>"
    if (irc.ne.0) then
       write(*,*)myname,'Error writing to:',unitx
       return
    end if
    close(unitx,iostat=irc)
    if (irc.ne.0) then
       write(*,*)myname,'Unable to close: ',crep%xmlo350(1:lenx)
       return
    end if
    return
  end subroutine writeReport
  !
  subroutine writeRecords(unitx,file,cpar,crep,irc)
    implicit none
    integer :: unitx
    type(filetype) :: file
    type(parameter),pointer :: cpar
    type(report),pointer :: crep
    integer :: irc
    character*25 x25,y25,z25,l25,d25
    integer lenx25,leny25,lenz25,lenl25,lend25
    integer :: yy,mm,dd,hh,mi
    real :: sec
    real :: val
    character*4 ayy
    character*2 amm,add,ahh
    character*700 :: keb700,i700
    character*60 :: b60
    integer :: cpos,opos,lenx,leni,lenk,lenb,lenk1,lenk2
    integer :: iepos,ifpos,idd,lenv,ilenv,ii,jj,kk,tt
    character*30 :: val30
    integer, external :: length
    real :: epos,fpos,trg
    real :: rpos,dpos
    real :: trgpos(mtrg)
    logical :: bok, brm, first
    real,allocatable :: avg(:)
    real :: savg, scnt
    integer,dimension(8) :: values
    CHARACTER*14 MYNAME 
    DATA MYNAME /'writeRecords'/
    do ii=1,crep%npst
       do tt=1,crep%ntim
          if (.not.crep%lfirst(tt,ii)) then
             ! check if record should be written...
             bok=.false.
             brm=.false.
             if (crep%ltrg) then
                do kk=1,crep%ntrg
                   if (crep%trgtyp(kk).eq.trg_macro) then
                      trgpos(kk)=0.0D0
                      bok=.true.
                   else
                      ! remember ascending order
                      if (crep%trgtyp(kk).eq.trg_fraction) then
                         rpos=max(0.0D0,min(1.0D0,crep%trgval(kk)))*&
                              & real(crep%nkey1(tt,ii)-1)&
                              & +1.0D0
                         !write(*,*)myname,'Fraction:',crep%trgval(kk),rpos
                      else if (crep%trgtyp(kk).eq.trg_area) then
                         trg=(crep%trgval(kk)/max(1.0D-5,file%darea)) ! #grid-cells
                         if (trg.lt.0.0D0) then
                            rpos=-trg ! from lowest end
                         else 
                            rpos=real(crep%nkey1(tt,ii))-trg ! from highest end
                         end if
                         !write(*,*)myname,'Area:',crep%trgval(kk),trg,rpos
                      else if (crep%trgtyp(kk).eq.trg_count) then
                         trg=crep%trgval(kk) ! #grid-cells
                         if (trg.ge.0.5D0) then
                            rpos=trg
                         else 
                            rpos=real(crep%nkey1(tt,ii))+trg
                         end if
                      else if (crep%trgtyp(kk).eq.trg_average) then
                         trg=crep%trgval(kk)
                         if (trg.lt.0.0D0) then ! average of values above
                            rpos=max(0.0D0,min(1.0D0,1.0D0-trg))*&
                                 & real(crep%nkey1(tt,ii)-1)&
                                 & +1.0D0
                         else                   ! average of values below
                            rpos=max(0.0D0,min(1.0D0,trg))*&
                                 & real(crep%nkey1(tt,ii)-1)&
                                 & +1.0D0
                         end if
                         ! write(*,*)myname,'Average:',crep%trgval(kk),rpos,crep%nkey1(tt,ii)
                      end if
                      trgpos(kk)=rpos
                      fpos=floor(rpos)
                      epos=ceiling(rpos)
                      dpos=max(1.0D0,epos-fpos)
                      ifpos=nint(fpos)
                      iepos=nint(epos)
                      !write(*,*)myname,'Nkey:',tt,crep%nkey1(tt,ii),crep%trgtyp(kk),crep%trgval(kk),rpos,ifpos,iepos
                      if (ifpos.ge.1 .and. iepos.le.crep%nkey1(tt,ii)) then ! ignore?
                         bok=.true.
                      else if (crep%trgreq(kk)) then
                         brm=.true.
                      end if
                   end if
                end do
             else
                bok=.true.
             end if
             !write(*,*)myname,'Here:',tt,brm,bok,crep%ltrg
             if (brm) bok=.false. ! did not meet requirements
             if (bok) then ! write record
                first=.true.
                ! write record
                call writeStart(unitx,tt,file,cpar,crep,irc)
                if (crep%ltrg) then
                   do kk=1,crep%ntrg
                      if (crep%trgtyp(kk).eq.trg_macro) then
                         var700=crep%trgvar700(kk)
                         call replaceXML(var700,mxmlvar,crep%xmlvar350(1,tt,ii))
                         lenv=length(var700,700,10)
                         write(unitx,'(A,A)',advance='no',iostat=irc) &
                              & "' "//trim(crep%trg10(kk))//"='",var700(1:lenv)
                      else
                         rpos=trgpos(kk)
                         fpos=floor(rpos)
                         epos=ceiling(rpos)
                         dpos=max(1.0D0,epos-fpos)
                         ifpos=nint(fpos)
                         iepos=nint(epos)
                         !write(*,*)myname,"There:",ifpos,iepos,rpos,crep%nkey1(tt,ii)
                         if (ifpos.ge.1 .and. iepos.le.crep%nkey1(tt,ii)) then ! ignore invalid requests... (->undefined level)
                            if (crep%trgtyp(kk).eq.trg_average) then
                               ! average of the values below
                               if (first) then
                                  first=.false.
                                  allocate(avg(crep%nkey1(tt,ii)),stat=irc)
                                  if (irc.ne.0) then
                                     write(*,*)myname,'Error return from initfile.',irc
                                     return
                                  end if
                                  ! make avg
                                  savg=0.0D0
                                  scnt=0.0D0
                                  do jj=1,crep%nkey1(tt,ii)
                                     savg=savg+crep%key1(crep%keyind(jj,tt,ii),tt,ii)
                                     scnt=scnt+1.0D0
                                     avg(jj)=savg/scnt ! average of the values below
                                     !write(*,*)myname,'Avg:',tt,jj,crep%key1(crep%keyind(jj,tt,ii),tt,ii),&
                                     !     & avg(jj),savg,scnt

                                  end do
                               end if
                               !write(*,*)myname,"Ind:",fpos,epos,(crep%keyind(jj,tt,ii),ii=1,crep%nkey1(tt,ii))
                               val=avg(ifpos)+(rpos-fpos)*&
                                    & (avg(iepos)-&
                                    & avg(ifpos))/dpos
                               if (crep%trgval(kk) .lt. 0) then ! average of the values above
                                  val= (savg - val*rpos)/scnt
                               end if
                            else
                               !write(*,*)myname,'Nkey:',tt,crep%nkey1(tt,ii),crep%trgtyp(kk),crep%trgval(kk),rpos,ifpos,iepos
                               val=crep%key1(crep%keyind(ifpos,tt,ii),tt,ii)+(rpos-fpos)*&
                                    & (crep%key1(crep%keyind(iepos,tt,ii),tt,ii)-&
                                    & crep%key1(crep%keyind(ifpos,tt,ii),tt,ii))/dpos
                            end if
                            val30=pretty30(val,lenv)
                            write(unitx,'(A,A)',advance='no',iostat=irc) &
                                 & "' "//trim(crep%trg10(kk))//"='",val30(1:lenv)
                         end if
                      end if
                   end do
                else
                   write(unitx,'(2(A,F0.8))',advance='no',iostat=irc) &
                        & "' max='",crep%valmax(tt,ii),&
                        & "' min='",crep%valmin(tt,ii)
                end if
                write(unitx,'(A)',iostat=irc) &
                     & "'/>"
                ! & "' time='"//z25(1:lenz25)//&
                ! & "' epoch='",crep%tj2000(tt),&
                if (allocated(avg)) deallocate(avg,stat=irc)
             end if
          end if
       end do
    end do
  end subroutine writeRecords
  !
  subroutine writeStart(unitx,tt,file,cpar,crep,irc)
    implicit none
    integer :: unitx
    integer :: tt
    type(filetype) :: file
    type(parameter),pointer :: cpar
    type(report),pointer :: crep
    integer :: irc
    character*25 x25,y25,z25,l25,d25
    integer lenx25,leny25,lenz25,lenl25,lend25
    integer :: yy,mm,dd,hh,mi
    real :: sec
    real :: val
    character*4 ayy
    character*2 amm,add,ahh
    character*700 :: keb700,i700
    character*60 :: b60
    integer :: cpos,opos,lenx,leni,lenk,lenb,lenk1,lenk2
    integer :: iepos,ifpos,idd,lenv,ilenv,ii
    character*30 :: val30
    integer, external :: length
    real :: epos,fpos,trg
    real :: rpos,dpos
    logical :: first
    integer,dimension(8) :: values
    CHARACTER*14 MYNAME 
    DATA MYNAME /'writeRecords'/
    write(l25,'("+",I0)') nint((crep%tj2000(tt)-file%a2000)*24.0D0);
    call chop0(l25,25)
    lenl25=length(l25,25,3);
    ! write(d25,'("+",I0)') int((crep%tj2000(tt)-int(file%a2000)));
    idd=int((crep%tj2000(tt)-int(file%i2000)));
    !write(*,*)myname,"DAY:",crep%tj2000(tt),file%i2000,idd
    if (idd.lt.0) then
       write(d25,'(I0)') idd
    else
       write(d25,'("+",I0)') idd
    end if
    call chop0(d25,25)
    lend25=length(d25,25,3);
    call dj2000(crep%tj2000(tt),yy,mm,dd,hh,mi,sec)
    x25=short25(yy,mm,dd,hh,mi,lenx25) ! dtg
    y25=short25(yy,mm,dd,00,00,leny25) ! date
    z25=short25(00,00,00,hh,mi,lenz25) ! time
    do ii=1,crep%npst
       write(unitx,'(4(A,F0.8),A)',advance='no',iostat=irc) &
            & "   <dtg dtg='"//x25(1:lenx25)//&
            & "' date='"//y25(1:leny25)//&
            & "' maxlat='",crep%llmax(1,tt,ii),&
            & "' maxlon='",crep%llmax(2,tt,ii),&
            & "' minlat='",crep%llmin(1,tt,ii),&
            & "' minlon='",crep%llmin(2,tt,ii),&
            & "' lead='"//l25(1:lenl25)//"' day='"//d25(1:lend25)
       if (crep%lavg.and.crep%valcnt(tt,ii).gt.0.0D0) then
          val=crep%valavg(tt,ii)/crep%valcnt(tt,ii)
          write(unitx,'(A,F0.8)',advance='no',iostat=irc) &
               & "' "//trim(crep%avg10)//"='",val
       end if
    end do
    return
  end subroutine writeStart
  !
  subroutine addPar(mxml,nxml,xml700,par,val)
    implicit none
    integer :: mxml
    integer :: nxml
    character*700 :: xml700(2,mxml)
    character*(*) par
    character*(*) val
    integer,external :: length
    integer :: II,lenp,lenv
    logical :: found
    CHARACTER*14 MYNAME 
    DATA MYNAME /'addPar'/
    lenp=len(trim(par))
    found=.false.
    do ii=1,nxml
       lenx=length(xml700(1,ii),700,lenp)
       if (xml700(1,ii)(max(1,lenx-lenp+1):lenx).eq.&
            & trim(par)) then
          found=.true.
          exit
       end if
    end do
    if (.not.found) then
       nxml=min(mxml,nxml+1)
       xml700(1,nxml)=par
       xml700(2,nxml)=val
       call chop0(xml700(1,nxml),700)
       call chop0(xml700(2,nxml),700)
    end if
    return
  end subroutine addPar
  !
  subroutine addXML(crep,par,val)
    implicit none
    type(report), pointer :: crep
    character*(*) par
    character*(*) val
    integer :: II,lenp,lenv
    logical :: found
    CHARACTER*14 MYNAME 
    DATA MYNAME /'addXML'/
    call addPar(mxml,crep%nxml,crep%xml700,par,val)
    return
  end subroutine addXML
  !
  subroutine addAux(crep,par,val)
    implicit none
    type(report), pointer :: crep
    character*(*) par
    character*(*) val
    integer :: II,lenp,lenv
    logical :: found
    CHARACTER*14 MYNAME 
    DATA MYNAME /'addXML'/
    integer maux,naux
    maux=1
    naux=0
    call addPar(maux,naux,crep%aux700,par,val)
    crep%laux=.true.
    return
  end subroutine addAux
  !
  subroutine addKEY(crep,par,val)
    implicit none
    type(report), pointer :: crep
    character*(*) par
    character*(*) val
    integer :: II,lenp,lenv
    logical :: found
    CHARACTER*14 MYNAME 
    DATA MYNAME /'addKEY'/
    call addPar(mkey,crep%nkey,crep%key700,par,val)
    return
  end subroutine addKEY
  !
  real function f1970(yy,mm,dd,hh,mi,sec)
    implicit none
    integer  :: yy,mm,dd,hh,mi
    real :: sec
    !     returns "seconds since 1970-01-01 00:00:00 +00:00"
    real days
    !     yy=1970
    !     mm=01
    !     dd=01
    !     mi=00
    !     sec=0.0D0
    !     call date2jd2000(days,yy,mm,dd,hh,mi,sec)
    !     write(*,*) 'S1970 1970-reference in J2000:',days!  2440587.5
    call date2jd(days,yy,mm,dd,hh,mi,sec) ! get days since 2000/1/1 0:0
    days = days - 2440587.5  ! convert to days since reference
    f1970=days*86400.0D0      ! convert to seconds
    return
  end function f1970
  subroutine date2jd (jd, year,month,day,hour,minutes,seconds)
    !     (corresponds to jd2000)
    !     computes julian day from gregorian (civil) calendar
    !     o  (real*8) jd = julian. day
    !     i  (int*4) yy = year
    !     i  (int*4) mm = month
    !     i  (int*4) dd = day
    !     i  (int*4) hh = hour
    !     i  (int*4) mi = minute
    !     i  (real*8) sec = second.
    implicit none
    real jd
    integer year,month,day,hour,minutes,i,j,k
    real seconds
    i= year
    j= month
    k= day
    jd= k-32075+1461*(i+4800+(j-14)/12)/4+367*(j-2-(j-14)/12*12) &
         /12-3*((i+4900+(j-14)/12)/100)/4
    jd=jd+((hour-12.0d0)/24.0d0)+(minutes/1440.0d0)+(seconds/86400.0d0)
    return
  end subroutine date2jd
  function short25(yy,mm,dd,hh,mi,len)
    implicit none
    character*25 :: short25
    integer :: yy
    integer :: mm
    integer :: dd
    integer :: hh
    integer :: mi
    integer :: len
    len=0
    if (yy.ne.0) then ! date
       if (len.ne.0) then
          short25(len+1:len+1)="_"
          len=len+1
       end if
       write(short25(len+1:len+10),'(I4.4,"-",I2.2,"-",I2.2)') yy,mm,dd
       len=len+10
    end if
    if (hh.ne.0.or.mi.ne.0) then
       if (len.ne.0) then
          short25(len+1:len+1)="_"
          len=len+1
       end if
       write(short25(len+1:len+2),'(I2.2)') hh
       len=len+2
       if (mi.ne.0) then
          short25(len+1:len+1)="-"
          len=len+1
          write(short25(len+1:len+2),'(I2.2)') mi
          len=len+2
       end if
    else if (yy.eq.0.and.len.eq.0) then
       short25(1:2)="00"
       len=2
    end if
    return
  end function short25

  character*30 function pretty30(val,ilenv)
    real :: val
    integer :: ilenv
    character*30 :: val30
    integer :: lenv,ii
    integer, external :: length
    character*1 :: c1
    C1=CHAR(0)
    write(val30,'(F0.8)',iostat=irc) val
    call chop0(val30,30)
    lenv=length(val30,30,10)
    ilenv=lenv
    do ii=lenv,1,-1
       if (ilenv.eq.ii .and. val30(ii:ii).eq."0") then
          ilenv=ilenv-1
       end if
    end do
    if (ilenv.lt.lenv.and.val30(ilenv:ilenv).eq.".") then
       ilenv=ilenv+1
    end if
    do ii=ilenv+1,min(lenv+1,30)
       val30(ii:ii)=c1
    end do
    pretty30=val30
    !if (ilenv.ne.lenv) then
    !   write(*,*)'Pretty:',val,' -> ',val30(1:ilenv),ilenv
    !end if
    return
  end function pretty30

  logical function isClose(lat,lon,minlat,maxlat,minlon,maxlon,delta)
    real :: lat,lon,minlat,maxlat,minlon,maxlon,delta
    real, parameter :: fact=360.0D0/40075.0D0
    real dlon,dlat
    dlat=delta*fact
    dlon=cosdeg(lat)*dlon
    isClose=.false.
    if (lat.ge.minlat-dlat .and. lat.le.maxlat+dlat) then
       if (lon.ge.minlon-dlon .and. lon.le.maxlon+dlon) then
          isClose=.true.
       end if
    end if
    return   
  end function isClose

  subroutine checkEdge(lat,lon,nn,lata,lona,delta,inout)
    real :: lat,lon
    integer :: nn
    real :: lata(nn), lona(nn)
    real :: delta
    integer :: inout
    integer :: ii
    real :: dist
    real, parameter :: fact=360.0D0/40075.0D0
    real :: deltaf
    deltaf=delta*fact ! convert to degrees
    do ii=1,nn
       dist=getDist(lat,lon,lata(ii),lona(ii)) ! get distance in degrees...
       if (dist < deltaf) then
          !write(*,*) 'checkEdge Found point:',lat,lon,ii,dist
          inout=0
          return
       end if
    end do
    return
  end subroutine checkEdge

end subroutine MNCMASK
